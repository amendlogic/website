---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs';
import path from 'node:path';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options: userOptions, // Umbenannt, da wir "options" evtl. neu berechnen
  csvPath, // NEUE PROP: Pfad zur CSV Datei (z.B. './src/data/strategy.csv')
  height = '400px',
  id,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

let finalOptions = userOptions;

// --- CSV PARSING LOGIK (Server-Side) ---
if (csvPath) {
  try {
    // 1. Datei lesen
    const filePath = path.resolve(csvPath);
    const fileContent = fs.readFileSync(filePath, 'utf-8');

    // 2. Einfacher CSV Parser
    const rows = fileContent.trim().split('\n').map(row => row.split(','));
    const headers = rows[0].map(h => h.trim());

    // Indizes finden (dynamisch, falls TradingView die Spalten ändert)
    const idxDate = headers.indexOf('Date/Time');
    const idxProfit = headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%')); // Vermeidet % Spalte
    const idxDD = headers.findIndex(h => h.includes('Drawdown') && !h.includes('%') && !h.includes('Max')); 

    const dateData = [];
    const profitData = [];
    const drawdownData = [];

    // 3. Daten extrahieren (ab Zeile 1, Zeile 0 ist Header)
    for (let i = 1; i < rows.length; i++) {
      const row = rows[i];
      
      // TradingView hat oft Entry und Exit Zeilen. Nur Zeilen mit "Cum. Profit" sind relevant (Exits).
      const profitVal = row[idxProfit];
      
      if (profitVal && profitVal.trim() !== '') {
        // Datum konvertieren (TradingView ISO String ist meist sicher)
        dateData.push(row[idxDate]);
        
        // Zahlen parsen (parseFloat)
        profitData.push(parseFloat(profitVal));
        
        // Drawdown ist in CSV meist positiv, für Chart oft negativ schöner oder als Area
        // Wir nehmen hier den absoluten Wert, ECharts kann ihn invertieren oder wir machen ihn negativ:
        const ddVal = parseFloat(row[idxDD] || 0);
        drawdownData.push(ddVal * -1); // Drawdown als negativer Wert für Unter-Wasser-Chart
      }
    }

    // 4. ECharts Options automatisch generieren
    finalOptions = {
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'cross' }
      },
      legend: {
        data: ['Equity (Cum. Profit)', 'Drawdown']
      },
      grid: {
        left: '3%', right: '4%', bottom: '3%', containLabel: true
      },
      xAxis: {
        type: 'category',
        data: dateData,
        boundaryGap: false
      },
      yAxis: [
        {
          type: 'value',
          name: 'Profit',
          position: 'left'
        },
        {
          type: 'value',
          name: 'Drawdown',
          position: 'right',
          max: 0, // Drawdown immer unter 0
          splitLine: { show: false }
        }
      ],
      series: [
        {
          name: 'Equity (Cum. Profit)',
          type: 'line',
          data: profitData,
          smooth: true,
          showSymbol: false,
          itemStyle: { color: '#10B981' }, // Grün
          areaStyle: { opacity: 0.1 }
        },
        {
          name: 'Drawdown',
          type: 'bar', // oder 'line' mit areaStyle
          yAxisIndex: 1,
          data: drawdownData,
          itemStyle: { color: '#EF4444' } // Rot
        }
      ]
    };

    // Merge: Falls der User eigene Options übergeben hat, diese überschreiben/ergänzen
    if (userOptions) {
        finalOptions = { ...finalOptions, ...userOptions };
    }

  } catch (e) {
    console.error(`Error parsing CSV at ${csvPath}:`, e);
  }
}

const chartId = `echart-${Math.random().toString(36).slice(2, 11)}`;
---

<WidgetWrapper id={id} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />

  {content && <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />}

  <div class="p-4 md:p-6 rounded-md shadow-xl dark:shadow-none dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div 
      id={chartId} 
      class="echart-container overflow-hidden w-full" 
      data-chart-options={JSON.stringify(finalOptions)} 
      style={`height:${height}; min-height:${height};`}
    ></div>
  </div>
</WidgetWrapper>

<script is:inline>
  // ... (Hier dein existierender Script Code) ...
  (function() {
    if (window.echarts_optimized_init) return;
    window.echarts_optimized_init = true;
    // ... Rest deines Codes ...
    let echartsLib = null;
    let resizeObserver = null;
    let cleanupFns = [];
    const instances = new Map();

    async function renderChart(container) {
      if (instances.has(container.id)) return;

      try {
        if (!echartsLib) {
          const mod = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js");
          echartsLib = mod.default || mod;
        }

        const chart = echartsLib.init(container, null, { renderer: 'canvas' });
        const options = JSON.parse(container.dataset.chartOptions || '{}');
        
        chart.setOption(options);
        instances.set(container.id, chart);

        if (resizeObserver) resizeObserver.observe(container);

      } catch (e) {
        console.error("Chart Render Error:", e);
      }
    }
    // ... Rest deines Codes (init, run, Observer) ...
    function init() {
      const containers = document.querySelectorAll('.echart-container');
      if (containers.length === 0) return;

      resizeObserver = new ResizeObserver((entries) => {
        entries.forEach(entry => {
          const chart = instances.get(entry.target.id);
          if (chart && !chart.isDisposed()) {
            chart.resize({ width: 'auto', animation: { duration: 0 } });
          }
        });
      });

      const viewportObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            renderChart(entry.target);
            observer.unobserve(entry.target);
          }
        });
      }, { rootMargin: '200px' });

      containers.forEach(c => viewportObserver.observe(c));

      cleanupFns.push(() => {
        viewportObserver.disconnect();
        resizeObserver.disconnect();
        instances.forEach(c => c.dispose());
        instances.clear();
      });
    }

    const run = () => {
      cleanupFns.forEach(fn => fn());
      cleanupFns = [];
      if (window.requestIdleCallback) window.requestIdleCallback(init);
      else setTimeout(init, 100);
    };

    document.addEventListener('astro:page-load', run);
  })();
</script>
