---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs';
import path from 'node:path';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options: userOptions,
  csvPath,
  height = '400px',
  id,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

let finalOptions = userOptions || {};

// --- CSV PARSING (Server-Side) ---
if (csvPath) {
  try {
    const filePath = path.resolve(csvPath);
    const fileContent = fs.readFileSync(filePath, 'utf-8');

    const rows = fileContent.trim().split(/\r?\n/).map(row => row.split(','));
    const headers = rows[0].map(h => h.trim());

    const idxDate = headers.indexOf('Date/Time');
    const idxProfit = headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%'));
    // Sucht nach Drawdown Spalte mit %
    const idxDD = headers.findIndex(h => h.includes('Drawdown') && h.includes('%'));

    const dateData = [];
    const profitData = [];
    const drawdownData = [];

    for (let i = 1; i < rows.length; i++) {
      const row = rows[i];
      const profitVal = row[idxProfit];

      if (profitVal && profitVal.trim() !== '') {
        let rawDate = row[idxDate];
        if (rawDate.includes('T')) rawDate = rawDate.split('T')[0];
        else if (rawDate.includes(' ')) rawDate = rawDate.split(' ')[0];
        
        dateData.push(rawDate);
        profitData.push(parseFloat(profitVal));

        const ddVal = parseFloat(row[idxDD] || 0);
        drawdownData.push(ddVal * -1); 
      }
    }

    finalOptions = {
      // --- BASIS LAYOUT ---
      grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
      tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
      legend: { data: ['Equity', 'Drawdown %'] },
      
      // --- ACHSEN (Farben werden im Client Script überschrieben) ---
      xAxis: { 
        type: 'category', 
        data: dateData, 
        boundaryGap: false 
      },
      yAxis: [
        { type: 'value', name: 'Equity', position: 'left' },
        { 
          type: 'value', 
          name: 'Drawdown (%)', 
          position: 'right', 
          min: -100, max: 0, 
          splitLine: { show: false },
          axisLabel: { formatter: '{value}%' } 
        }
      ],
      series: [
        {
          name: 'Equity',
          type: 'line',
          data: profitData,
          smooth: true,
          showSymbol: false,
          itemStyle: { color: '#10B981' }, // AstroWind Grün
          areaStyle: { opacity: 0.1 }
        },
        {
          name: 'Drawdown %',
          type: 'bar',
          yAxisIndex: 1,
          data: drawdownData,
          itemStyle: { color: '#EF4444' } // AstroWind Rot
        }
      ]
    };

    if (userOptions) {
      finalOptions = { ...finalOptions, ...userOptions };
    }

  } catch (e) {
    console.error(`Error parsing CSV at ${csvPath}:`, e);
  }
}

const chartId = id ?? `echart-${Math.random().toString(36).slice(2, 11)}`;
const safeOptions = JSON.stringify(finalOptions).replace(/</g, '\\u003c');
---

<WidgetWrapper id={chartId} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />

  {content && (
    <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />
  )}

  <div class="p-4 md:p-6 rounded-md shadow-xl dark:shadow-none dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div
      id={chartId}
      class="echart-container overflow-hidden w-full"
      data-chart-options={safeOptions}
      style={`height:${height}; min-height:${height};`}
    ></div>
  </div>
</WidgetWrapper>

<script is:inline>
(function () {
  if (window.echarts_optimized_init) return;
  window.echarts_optimized_init = true;

  let echartsLib = null;
  let resizeObserver = null;
  let themeObserver = null;
  let cleanupFns = [];
  const instances = new Map();

  // --- ASTROWIND FARBPALETTE (Tailwind Slate) ---
  const getThemeColors = () => {
    const isDark = document.documentElement.classList.contains('dark');
    return {
      text: isDark ? '#cbd5e1' : '#475569',      // slate-300 vs slate-600
      axis: isDark ? '#64748b' : '#94a3b8',      // slate-500 vs slate-400
      split: isDark ? '#334155' : '#e2e8f0',     // slate-700 vs slate-200
      tooltipBg: isDark ? 'rgba(30, 41, 59, 0.9)' : 'rgba(255, 255, 255, 0.9)', // slate-800 vs white
      tooltipBorder: isDark ? '#475569' : '#cbd5e1',
      tooltipText: isDark ? '#f1f5f9' : '#1e293b'
    };
  };

  async function renderChart(container) {
    if (instances.has(container.id)) return;

    try {
      if (!echartsLib) {
        const mod = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js");
        echartsLib = mod.default || mod;
      }

      const chart = echartsLib.init(container, null, { renderer: 'canvas' });
      const options = JSON.parse(container.dataset.chartOptions || '{}');
      const colors = getThemeColors();

      // --- 1. TOOLTIP FORMATTER FIX ---
      if (!options.tooltip) options.tooltip = {};
      options.tooltip.formatter = function (params) {
          const equity = params.find(p => p.seriesName.includes('Equity'));
          const dd = params.find(p => p.seriesName.includes('Drawdown'));
          
          let html = `<strong>${params[0].axisValue}</strong><br/>`;
          if (equity) html += `Equity: ${equity.value.toLocaleString()}<br/>`;
          if (dd) html += `Drawdown: ${Math.abs(dd.value)}%`;
          return html;
      };

      // --- 2. FARBEN ANWENDEN ---
      const applyTheme = (opts, themeColors) => {
        // Legende
        if (!opts.legend) opts.legend = {};
        opts.legend.textStyle = { color: themeColors.text };
        
        // Tooltip Styling
        if (!opts.tooltip) opts.tooltip = {};
        opts.tooltip.backgroundColor = themeColors.tooltipBg;
        opts.tooltip.borderColor = themeColors.tooltipBorder;
        opts.tooltip.textStyle = { color: themeColors.tooltipText };

        // Achsen Styling (X und Y)
        const styleAxis = (axis) => {
           if (!axis) return;
           axis.axisLine = { lineStyle: { color: themeColors.axis } };
           axis.axisLabel = { color: themeColors.text, ...(axis.axisLabel || {}) };
           axis.nameTextStyle = { color: themeColors.text };
           axis.splitLine = { 
               show: axis.splitLine?.show ?? true, // Behalte show settings bei
               lineStyle: { color: themeColors.split } 
           };
        };

        if (opts.xAxis) styleAxis(opts.xAxis);
        if (opts.yAxis && Array.isArray(opts.yAxis)) {
            opts.yAxis.forEach(styleAxis);
        } else if (opts.yAxis) {
            styleAxis(opts.yAxis);
        }
        return opts;
      };

      // Initial anwenden
      chart.setOption(applyTheme(options, colors));
      instances.set(container.id, chart);
      
      if (resizeObserver) resizeObserver.observe(container);

    } catch (e) {
      console.error("Chart Render Error:", e);
    }
  }

  function init() {
    const containers = document.querySelectorAll('.echart-container');
    if (containers.length === 0) return;

    // --- VIEWPORT OBSERVER ---
    const viewportObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          renderChart(entry.target);
          observer.unobserve(entry.target);
        }
      });
    }, { rootMargin: '200px' });
    containers.forEach(c => viewportObserver.observe(c));

    // --- RESIZE OBSERVER ---
    resizeObserver = new ResizeObserver(entries => {
      entries.forEach(entry => {
        const chart = instances.get(entry.target.id);
        if (chart && !chart.isDisposed()) {
          chart.resize({ width: 'auto', animation: { duration: 0 } });
        }
      });
    });

    // --- THEME OBSERVER (Der AstroWind Magic Part) ---
    // Beobachtet das <html> Element auf Klassenänderungen (dark mode toggle)
    themeObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          const newColors = getThemeColors();
          instances.forEach((chart) => {
            // Wir updaten nur die Styling-Teile
            chart.setOption({
                legend: { textStyle: { color: newColors.text } },
                tooltip: { 
                    backgroundColor: newColors.tooltipBg,
                    borderColor: newColors.tooltipBorder,
                    textStyle: { color: newColors.tooltipText }
                },
                xAxis: {
                    axisLine: { lineStyle: { color: newColors.axis } },
                    axisLabel: { color: newColors.text },
                    splitLine: { lineStyle: { color: newColors.split } }
                },
                yAxis: [
                    {   // Linke Achse
                        axisLine: { lineStyle: { color: newColors.axis } },
                        axisLabel: { color: newColors.text },
                        nameTextStyle: { color: newColors.text },
                        splitLine: { lineStyle: { color: newColors.split } }
                    },
                    {   // Rechte Achse
                        axisLine: { lineStyle: { color: newColors.axis } },
                        axisLabel: { color: newColors.text },
                        nameTextStyle: { color: newColors.text }
                    }
                ]
            });
          });
        }
      });
    });
    
    themeObserver.observe(document.documentElement, { attributes: true });

    // Cleanup registrieren
    cleanupFns.push(() => {
      viewportObserver.disconnect();
      resizeObserver.disconnect();
      themeObserver.disconnect();
      instances.forEach(c => c.dispose());
      instances.clear();
    });
  }

  const run = () => {
    cleanupFns.forEach(fn => fn());
    cleanupFns = [];
    if (window.requestIdleCallback) window.requestIdleCallback(init);
    else setTimeout(init, 100);
  };

  document.addEventListener('astro:page-load', run);
})();
</script>
