---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs';
import path from 'node:path';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options: userOptions = {}, // Leeres Objekt als Default
  csvPath,
  height = '450px',
  id,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

let baseOptions = {};

// --- 1. CSV Parsing (Bleibt robust, aber kompakt) ---
if (csvPath) {
  try {
    const fileContent = fs.readFileSync(path.resolve(csvPath), 'utf-8');
    const rows = fileContent.trim().split(/\r?\n/).filter(Boolean).map(row => row.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/));
    const headers = rows[0].map(h => h.trim());

    const idx = {
      date: headers.indexOf('Date/Time'),
      profit: headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%')),
      dd: headers.findIndex(h => h.includes('Drawdown') && h.includes('%'))
    };

    const data = { equity: [], dd: [] };

    for (let i = 1; i < rows.length; i++) {
      const row = rows[i];
      const d = new Date(row[idx.date]);
      if (row[idx.profit] && !isNaN(d.getTime())) {
        data.equity.push([d.toISOString(), parseFloat(row[idx.profit])]);
        data.dd.push([d.toISOString(), Math.abs(parseFloat(row[idx.dd] || 0)) * -1]);
      }
    }

    // Basis-Konfiguration
    baseOptions = {
      grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
      tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, confine: true },
      legend: { data: ['Equity', 'Drawdown %'] },
      xAxis: { type: 'time', boundaryGap: false },
      yAxis: [
        { type: 'value', name: 'Equity', position: 'left', scale: true, splitLine: { show: true } },
        { type: 'value', name: 'Drawdown (%)', position: 'right', min: -100, max: 0, axisLabel: { formatter: '{value}%' }, splitLine: { show: false } }
      ],
      series: [
        { name: 'Equity', type: 'line', sampling: 'lttb', showSymbol: false, areaStyle: { opacity: 0.1 }, itemStyle: { color: '#10B981' }, data: data.equity },
        { name: 'Drawdown %', type: 'bar', yAxisIndex: 1, itemStyle: { color: '#EF4444', opacity: 0.5 }, data: data.dd }
      ]
    };
  } catch (e) { console.error(`CSV Error: ${e.message}`); }
}

const chartId = id ?? `echart-${Math.random().toString(36).slice(2, 11)}`;
---

<WidgetWrapper id={chartId} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />
  {content && <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />}
  
  <div class="p-4 md:p-6 rounded-md shadow-xl dark:shadow-none dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div 
      id={chartId} 
      class="echart-container w-full" 
      data-base={JSON.stringify(baseOptions)} 
      data-user={JSON.stringify(userOptions)}
      style={`height:${height}; min-height:${height};`}
    ></div>
  </div>
</WidgetWrapper>

<script is:inline>
(function () {
  if (window.echarts_init) return;
  window.echarts_init = true;

  const getColors = () => {
    const isDark = document.documentElement.classList.contains('dark');
    return {
      text: isDark ? '#cbd5e1' : '#475569',
      split: isDark ? '#334155' : '#e2e8f0',
      bg: isDark ? 'rgba(30,41,59,0.95)' : 'rgba(255,255,255,0.95)',
      border: isDark ? '#475569' : '#cbd5e1'
    };
  };

  const updateTheme = (chart) => {
    const c = getColors();
    // ECharts "Smart Update": Wir setzen nur Farben, der Rest bleibt erhalten
    chart.setOption({
      legend: { textStyle: { color: c.text } },
      tooltip: { backgroundColor: c.bg, borderColor: c.border, textStyle: { color: c.text } },
      textStyle: { color: c.text }, // Vererbt sich auf Achsen-Labels & Namen!
      yAxis: [{ splitLine: { lineStyle: { color: c.split } } }, {}], // Nur Splitlines explizit färben
      xAxis: { splitLine: { lineStyle: { color: c.split } } }
    });
  };

  const render = async (el) => {
    if (el._echarts) return; // Schutz vor Doppel-Init
    
    const echarts = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js").then(m => m.default || m);
    const chart = echarts.init(el, null, { renderer: 'canvas' });
    el._echarts = chart; // Chart Instanz am DOM-Element speichern

    const baseOpts = JSON.parse(el.dataset.base || '{}');
    const userOpts = JSON.parse(el.dataset.user || '{}');

    // 1. Tooltip Funktion (Kann nicht per JSON kommen)
    baseOpts.tooltip.formatter = (params) => {
      const date = new Date(params[0].value[0]).toLocaleDateString();
      let html = `<strong>${date}</strong><br/>`;
      params.forEach(p => {
         const val = p.seriesName.includes('Drawdown') ? Math.abs(p.value[1]) + '%' : p.value[1].toFixed(2);
         html += `${p.marker} ${p.seriesName}: ${val}<br/>`;
      });
      return html;
    };

    // 2. Daten laden (ECharts mischt userOpts automatisch dazu!)
    chart.setOption(baseOpts);
    chart.setOption(userOpts);
    
    // 3. Farben initial setzen
    updateTheme(chart);

    // 4. Observer für Resize & Theme Change
    new ResizeObserver(() => chart.resize()).observe(el);
  };

  // Init Logic (Lazy Loading + Theme Watcher)
  const init = () => {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(e => { if(e.isIntersecting) { render(e.target); observer.unobserve(e.target); }});
    }, { rootMargin: '200px' });
    
    document.querySelectorAll('.echart-container').forEach(el => observer.observe(el));

    // Globaler Theme Watcher (nur 1x für alle Charts)
    new MutationObserver((m) => {
      if (m.some(x => x.attributeName === 'class')) {
        document.querySelectorAll('.echart-container').forEach(el => el._echarts && updateTheme(el._echarts));
      }
    }).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
  };

  document.addEventListener('astro:page-load', init); // Astro Support
  if (document.readyState !== 'loading') init(); // Fallback Support
})();
</script>
