---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs/promises';
import path from 'node:path';
import { existsSync } from 'node:fs';

const currentLocale = Astro.currentLocale || 'de';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options: userOptions = {},
  csvPath,
  height = '450px',
  id,
  locale = currentLocale,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

const INITIAL_CAPITAL = 300;

// IDs
const uid = Math.random().toString(36).slice(2, 9);
const wrapperId = id ?? `widget-${uid}`;
const chartId = `chart-${uid}`;
const dataId = `data-${uid}`;

let baseOptions = {};

// --- SERVER SIDE PARSING ---
if (csvPath) {
  try {
    const absolutePath = path.resolve(csvPath);
    
    if (existsSync(absolutePath)) {
      const fileContent = await fs.readFile(absolutePath, 'utf-8');
      const lines = fileContent.trim().split(/\r?\n/);

      if (lines.length > 1) {
        const headers = lines[0].split(',').map(h => h.trim());
        const idx = {
          date: headers.indexOf('Date/Time'),
          profit: headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%')),
          dd: headers.findIndex(h => h.includes('Drawdown') && h.includes('%')),
          price: headers.indexOf('Price'),
          contracts: headers.indexOf('Contracts')
        };

        if (idx.date !== -1 && idx.profit !== -1) {
            const equity = [];
            const drawdown = [];
            const bnh = [];
            let firstPrice = null;
            let initialContracts = 1;
            const csvSplitRegex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;

            for (let i = 1; i < lines.length; i++) {
                const rawRow = lines[i];
                if (!rawRow) continue;
                // CSV Split logic
                const row = rawRow.split(csvSplitRegex).map(v => v.replace(/"/g, '').trim());

                const d = new Date(row[idx.date]);
                if (isNaN(d.getTime())) continue;
                const isoDate = d.toISOString();

                const profit = parseFloat(row[idx.profit]);
                const price = idx.price !== -1 ? parseFloat(row[idx.price]) : NaN;
                const dd = idx.dd !== -1 ? parseFloat(row[idx.dd]) : NaN;

                if (!isNaN(profit)) equity.push([isoDate, +(INITIAL_CAPITAL + profit).toFixed(2)]);
                if (!isNaN(dd)) drawdown.push([isoDate, -Math.abs(dd)]);

                if (!isNaN(price)) {
                    if (firstPrice === null) {
                        firstPrice = price;
                        const c = idx.contracts !== -1 ? parseFloat(row[idx.contracts]) : NaN;
                        if (!isNaN(c)) initialContracts = c;
                        bnh.push([isoDate, INITIAL_CAPITAL]);
                    } else {
                        const bnhProfit = (price - firstPrice) * initialContracts;
                        bnh.push([isoDate, +(INITIAL_CAPITAL + bnhProfit).toFixed(2)]);
                    }
                }
            }

            baseOptions = {
                grid: { left: 0, right: 0, bottom: 0, containLabel: true },
                legend: { data: ['Portfolio Value', 'Buy & Hold', 'Drawdown %'], top: 0 },
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, confine: true },
                xAxis: { type: 'time', boundaryGap: false },
                yAxis: [
                    { type: 'value', scale: true, splitLine: { show: true } },
                    { type: 'value', max: 0, splitLine: { show: false } }
                ],
                series: [
                    { name: 'Portfolio Value', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, areaStyle: { opacity: 0.1 }, itemStyle: { color: '#10B981' }, data: equity },
                    { name: 'Buy & Hold', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, lineStyle: { type: 'dashed' }, itemStyle: { color: '#94a3b8' }, data: bnh },
                    { name: 'Drawdown %', type: 'bar', yAxisIndex: 1, itemStyle: { color: '#EF4444', opacity: 0.5 }, data: drawdown }
                ]
            };
        }
      }
    }
  } catch (e) {
    console.error('[EChart CSV Error]:', e.message);
  }
}
---

<WidgetWrapper id={wrapperId} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />
  {content && <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />}

  <div class="p-4 md:p-6 rounded-md shadow-xl dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div 
      id={chartId} 
      data-json-id={dataId}
      class="echart-container w-full overflow-hidden" 
      style={`height:${height};`}
    ></div>
  </div>
</WidgetWrapper>

<script type="application/json" id={dataId} set:html={JSON.stringify({ baseOptions, userOptions, locale })} />

<script is:inline>
(() => {
  const chartMap = new Map();
  let resizeObserver;
  let mutationObserver;

  // Theme Logik ausgelagert fÃ¼r Wiederverwendbarkeit
  const getThemeConfig = () => {
    const dark = document.documentElement.classList.contains('dark');
    const text = dark ? '#cbd5e1' : '#475569';
    const split = dark ? '#334155' : '#e2e8f0';
    const bg = dark ? 'rgba(30,41,59,0.95)' : 'rgba(255,255,255,0.95)';
    const border = dark ? '#475569' : '#cbd5e1';
    
    return {
       textStyle: { color: text },
       legend: { textStyle: { color: text } },
       tooltip: { backgroundColor: bg, borderColor: border, textStyle: { color: text } },
       xAxis: { splitLine: { lineStyle: { color: split } } },
       yAxis: [{ splitLine: { lineStyle: { color: split } } }, { splitLine: { show: false } }]
    };
  };

  const render = async (el) => {
    if (el.getAttribute('data-loaded') === 'true') return;

    const jsonId = el.getAttribute('data-json-id');
    const script = document.getElementById(jsonId);
    if (!script) return;

    let config;
    try { config = JSON.parse(script.textContent); } catch { return; }
    
    if (!config.baseOptions || !Object.keys(config.baseOptions).length) return;

    const echarts = await import("https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.esm.min.js")
      .then(m => m.default || m);

    const chart = echarts.init(el);
    const { baseOptions, userOptions, locale } = config;

    // Formatters einmalig erstellen
    const axisFormat = new Intl.NumberFormat('en-US', { notation: "compact", maximumFractionDigits: 1 });
    const currencyFormat = new Intl.NumberFormat(locale, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const dateFormat = new Intl.DateTimeFormat(locale, { dateStyle: 'medium', timeStyle: 'short' });

    // Formatters injizieren
    if (baseOptions.yAxis && baseOptions.yAxis[0]) {
        baseOptions.yAxis[0].axisLabel = { formatter: val => axisFormat.format(val) };
    }

    if (baseOptions.tooltip) {
        baseOptions.tooltip.formatter = (params) => {
            const items = Array.isArray(params) ? params : [params];
            if (!items.length) return '';
            const dateVal = items[0].value[0];
            let html = `<div class="font-bold mb-1">${dateFormat.format(new Date(dateVal))}</div>`;
            items.forEach(p => {
                const val = p.seriesName.includes('Drawdown')
                  ? Math.abs(p.value[1]).toFixed(2) + '%'
                  : currencyFormat.format(p.value[1]);
                html += `<div class="flex justify-between gap-4">
                           <span>${p.marker} ${p.seriesName}</span>
                           <span class="font-mono font-bold">${val}</span>
                         </div>`;
            });
            return html;
        };
    }

    // Optionen setzen (ECharts merged automatisch shallow)
    chart.setOption(baseOptions);
    if (userOptions) chart.setOption(userOptions);
    
    // Theme anwenden
    chart.setOption(getThemeConfig());

    chartMap.set(el, chart);
    el.setAttribute('data-loaded', 'true');
  };

  const init = () => {
    cleanup();

    // 1. IntersectionObserver (Lazy Load)
    const observer = new IntersectionObserver(entries => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          render(e.target);
          observer.unobserve(e.target);
          // Wenn geladen, starte Resize Beobachtung
          if(resizeObserver) resizeObserver.observe(e.target);
        }
      });
    }, { rootMargin: '200px' });

    // 2. ResizeObserver (Responsiveness)
    resizeObserver = new ResizeObserver(entries => {
        entries.forEach(e => {
            const chart = chartMap.get(e.target);
            if (chart) chart.resize();
        });
    });

    // 3. MutationObserver (Dark Mode Live-Update)
    mutationObserver = new MutationObserver((mutations) => {
        if (mutations.some(m => m.attributeName === 'class')) {
            const themeOptions = getThemeConfig();
            chartMap.forEach(chart => chart.setOption(themeOptions));
        }
    });
    mutationObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });

    document.querySelectorAll('.echart-container').forEach(el => observer.observe(el));
  };

  const cleanup = () => {
    chartMap.forEach(c => c.dispose());
    chartMap.clear();
    if (resizeObserver) resizeObserver.disconnect();
    if (mutationObserver) mutationObserver.disconnect();
  };

  document.addEventListener('astro:page-load', init);
  document.addEventListener('astro:before-swap', cleanup);
  if (document.readyState !== 'loading') init();

})();
</script>
