---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs';
import path from 'node:path';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options: userOptions = {},
  csvPath,
  height = '450px',
  id,
  locale = 'de-DE', // Locale Übergabe
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

const INITIAL_CAPITAL = 300;

// IDs generieren
const wrapperId = id ?? `widget-${Math.random().toString(36).slice(2, 9)}`;
const chartId = `chart-${wrapperId}`;
const dataId = `data-${wrapperId}`;

let baseOptions = {};

// --- SERVER SIDE PARSING ---
if (csvPath) {
  try {
    const fileContent = fs.readFileSync(path.resolve(csvPath), 'utf-8');
    const lines = fileContent.trim().split(/\r?\n/);

    if (lines.length > 1) {
      const headers = lines[0].split(',').map(h => h.trim());
      const idx = {
        date: headers.indexOf('Date/Time'),
        profit: headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%')),
        dd: headers.findIndex(h => h.includes('Drawdown') && h.includes('%')),
        price: headers.indexOf('Price'),
        contracts: headers.indexOf('Contracts')
      };

      const equity = [];
      const drawdown = [];
      const bnh = [];

      let firstPrice = null;
      let initialContracts = 1;

      for (let i = 1; i < lines.length; i++) {
        // Robuster Split
        const row = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.replace(/"/g, '').trim());
        if (!row[idx.date]) continue;

        const d = new Date(row[idx.date]);
        if (isNaN(d.getTime())) continue;

        const isoDate = d.toISOString();
        const profit = parseFloat(row[idx.profit]);
        const price = parseFloat(row[idx.price]);
        const dd = parseFloat(row[idx.dd]);

        if (!isNaN(profit)) equity.push([isoDate, INITIAL_CAPITAL + profit]);
        if (!isNaN(dd)) drawdown.push([isoDate, -Math.abs(dd)]);

        if (firstPrice === null && !isNaN(price)) {
          firstPrice = price;
          const c = parseFloat(row[idx.contracts]);
          if (!isNaN(c)) initialContracts = c;
          bnh.push([isoDate, INITIAL_CAPITAL]);
        } else if (!isNaN(price)) {
          const bnhProfit = (price - firstPrice) * initialContracts;
          bnh.push([isoDate, INITIAL_CAPITAL + bnhProfit]);
        }
      }

      baseOptions = {
        // HIER: Farben wiederhergestellt für AstroWind Look
        grid: { left: 0, right: 0, bottom: 0, containLabel: true },
        tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, confine: true },
        legend: { data: ['Portfolio Value', 'Buy & Hold', 'Drawdown %'], top: 0 },
        xAxis: { type: 'time', boundaryGap: false },
        yAxis: [
          { type: 'value', scale: true, splitLine: { show: true } },
          { type: 'value', max: 0, splitLine: { show: false }, axisLabel: { formatter: '{value}%' } }
        ],
        series: [
          { 
            name: 'Portfolio Value', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, 
            areaStyle: { opacity: 0.1 }, 
            itemStyle: { color: '#10B981' }, // Grün
            data: equity 
          },
          { 
            name: 'Buy & Hold', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, 
            lineStyle: { type: 'dashed' }, 
            itemStyle: { color: '#94a3b8' }, // Grau
            data: bnh 
          },
          { 
            name: 'Drawdown %', type: 'bar', yAxisIndex: 1, 
            itemStyle: { color: '#EF4444', opacity: 0.9 }, // Rot Transparent
            data: drawdown 
          }
        ]
      };
    }
  } catch (e) { console.error(`[EChart CSV Error]: ${e.message}`); }
}
---

<WidgetWrapper id={wrapperId} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />
  {content && <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />}

  <div class="p-4 md:p-6 rounded-md shadow-xl dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div id={chartId} class="echart-container w-full overflow-hidden" style={`height:${height};`}></div>
  </div>
</WidgetWrapper>

<script type="application/json" id={dataId}>
  {JSON.stringify({ baseOptions, userOptions, locale })}
</script>

<script is:inline>
(() => {
  // Map statt Set, um Element -> Chart zuzuordnen (Wichtig für Resize!)
  const chartMap = new Map();
  let resizeObserver;
  let intersectionObserver;
  let mutationObserver;

  const getThemeColors = () => {
    const dark = document.documentElement.classList.contains('dark');
    return {
      text: dark ? '#cbd5e1' : '#475569',
      split: dark ? '#334155' : '#e2e8f0',
      bg: dark ? 'rgba(30,41,59,0.95)' : 'rgba(255,255,255,0.95)',
      border: dark ? '#475569' : '#cbd5e1'
    };
  };

  const applyTheme = (chart) => {
    const c = getThemeColors();
    chart.setOption({
      textStyle: { color: c.text },
      legend: { textStyle: { color: c.text } },
      tooltip: { backgroundColor: c.bg, borderColor: c.border, textStyle: { color: c.text } },
      xAxis: { splitLine: { lineStyle: { color: c.split } } },
      yAxis: [{ splitLine: { lineStyle: { color: c.split } } }, {}]
    });
  };

  const renderChart = async (el) => {
    if (el.dataset.initialized) return;

    // ID Logik um Script zu finden
    const currentId = el.id.replace('chart-', '');
    const dataScript = document.getElementById(`data-${currentId}`);
    if (!dataScript) return;

    const { baseOptions, userOptions, locale } = JSON.parse(dataScript.textContent);

    const echarts = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js")
      .then(m => m.default || m);

    const chart = echarts.init(el);

    // Number Formatter (10k, 1.5M)
    const numberFormatter = new Intl.NumberFormat(locale || 'en-US', {
      notation: "compact",
      maximumFractionDigits: 1
    });

    if (baseOptions.yAxis?.[0]) {
      baseOptions.yAxis[0].axisLabel = {
        formatter: val => numberFormatter.format(val)
      };
    }
    
    // Tooltip Formatter wiederherstellen
    if (baseOptions.tooltip) {
      baseOptions.tooltip.formatter = (params) => {
        const date = new Date(params[0].value[0]).toLocaleDateString();
        let html = `<strong>${date}</strong><br/>`;
        params.forEach(p => {
          const val = p.seriesName.includes('Drawdown') 
            ? Math.abs(p.value[1]).toFixed(2) + '%' 
            : p.value[1].toLocaleString(undefined, { minimumFractionDigits: 2 });
          html += `${p.marker} ${p.seriesName}: ${val}<br/>`;
        });
        return html;
      };
    }

    chart.setOption(baseOptions);
    chart.setOption(userOptions);
    applyTheme(chart);

    // In Map speichern: DOM Element -> ECharts Instanz
    chartMap.set(el, chart);
    el.dataset.initialized = "true";
  };

  const init = () => {
    // 1. Resize Observer: Korrigiert für mehrere Charts & Mobile
    resizeObserver = new ResizeObserver(entries => {
      entries.forEach(e => {
        const chart = chartMap.get(e.target); // Hole GENAU den Chart für dieses Element
        if (chart) chart.resize({ width: 'auto' }); // Fix für Mobile Landscape
      });
    });

    // 2. Intersection Observer (Lazy Load)
    intersectionObserver = new IntersectionObserver((entries, obs) => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          renderChart(e.target);
          obs.unobserve(e.target);
          resizeObserver.observe(e.target); // Erst beobachten wenn sichtbar
        }
      });
    }, { rootMargin: "200px" });

    document.querySelectorAll('.echart-container').forEach(el => {
      intersectionObserver.observe(el);
    });

    // 3. Mutation Observer (Live Dark Mode Switch)
    mutationObserver = new MutationObserver((m) => {
      if (m.some(x => x.attributeName === 'class')) {
        chartMap.forEach(chart => applyTheme(chart));
      }
    });
    mutationObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
  };

  document.addEventListener('astro:page-load', init);
  
  // Cleanup für View Transitions
  document.addEventListener('astro:before-swap', () => {
    chartMap.forEach(c => c.dispose());
    chartMap.clear();
    if (resizeObserver) resizeObserver.disconnect();
    if (intersectionObserver) intersectionObserver.disconnect();
    if (mutationObserver) mutationObserver.disconnect();
  });

  if (document.readyState !== 'loading') init();

})();
</script>