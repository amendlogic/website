---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs';
import path from 'node:path';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options: userOptions = {},
  csvPath,
  height = '450px',
  id,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

let baseOptions = {};

// --- KONFIGURATION STARTKAPITAL ---
const INITIAL_CAPITAL = 300; 

// --- CSV Parsing (Server-Side) ---
if (csvPath) {
  try {
    const fileContent = fs.readFileSync(path.resolve(csvPath), 'utf-8');
    const rows = fileContent.trim().split(/\r?\n/).filter(Boolean).map(row => row.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/));
    const headers = rows[0].map(h => h.trim());

    const idx = {
      date: headers.indexOf('Date/Time'),
      profit: headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%')),
      dd: headers.findIndex(h => h.includes('Drawdown') && h.includes('%')),
      price: headers.indexOf('Price'),
      contracts: headers.indexOf('Contracts')
    };

    const data = { equity: [], dd: [], bnh: [] };
    let firstPrice = null;
    let initialContracts = 1;

    for (let i = 1; i < rows.length; i++) {
      const row = rows[i];
      const d = new Date(row[idx.date]);
      
      if (!isNaN(d.getTime()) && row[idx.profit]) {
        const isoDate = d.toISOString();
        const currentProfit = parseFloat(row[idx.profit]);
        const currentPrice = parseFloat(row[idx.price]);

        // 1. Portfolio Value & Drawdown
        data.equity.push([isoDate, INITIAL_CAPITAL + currentProfit]);
        data.dd.push([isoDate, Math.abs(parseFloat(row[idx.dd] || 0)) * -1]);

        // 2. Buy & Hold Berechnung
        if (firstPrice === null && !isNaN(currentPrice)) {
            firstPrice = currentPrice;
            const c = parseFloat(row[idx.contracts]);
            if (!isNaN(c)) initialContracts = c;
            data.bnh.push([isoDate, INITIAL_CAPITAL]); 
        } else if (firstPrice !== null && !isNaN(currentPrice)) {
            const bnhProfit = (currentPrice - firstPrice) * initialContracts;
            data.bnh.push([isoDate, INITIAL_CAPITAL + bnhProfit]);
        }
      }
    }

    baseOptions = {
      // ÄNDERUNG: Manuelle Abstände entfernt. 
      // containLabel: true sorgt für automatische Berechnung der Ränder.
      grid: { left: 10, right: 10, bottom: 10, top: 60, containLabel: true },
      
      tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, confine: true },
      
      legend: { 
        data: ['Portfolio Value', 'Buy & Hold', 'Drawdown %']
      },

      xAxis: { type: 'time', boundaryGap: false },
      
      yAxis: [
        { 
          type: 'value', 
          name: 'Value', 
          position: 'left', 
          scale: true, 
          splitLine: { show: true },
          alignTicks: true,
          nameTextStyle: { align: 'left', fontWeight: 'bold' } 
        },
        { 
          type: 'value', 
          name: 'Drawdown (%)', 
          position: 'right', 
          max: 0, 
          axisLabel: { formatter: '{value}%' }, 
          splitLine: { show: false },
          nameTextStyle: { align: 'right', fontWeight: 'bold' }
        }
      ],
      series: [
        { name: 'Portfolio Value', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, areaStyle: { opacity: 0.1 }, itemStyle: { color: '#10B981' }, data: data.equity },
        { name: 'Buy & Hold', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, lineStyle: { type: 'dashed', width: 2 }, itemStyle: { color: '#94a3b8' }, data: data.bnh },
        { name: 'Drawdown %', type: 'bar', yAxisIndex: 1, itemStyle: { color: '#EF4444', opacity: 0.5 }, data: data.dd }
      ]
    };
  } catch (e) { console.error(`[EChart CSV Error]: ${e.message}`); }
}

const chartId = id ?? `echart-${Math.random().toString(36).slice(2, 11)}`;
---

<WidgetWrapper id={chartId} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />
  
  {content && <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />}
  
  <div class="rounded-md shadow-xl dark:shadow-none dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div 
      id={chartId} 
      class="echart-container w-full overflow-hidden" 
      data-base={JSON.stringify(baseOptions)} 
      data-user={JSON.stringify(userOptions)}
      style={`height:${height}; min-height:${height};`}
    ></div>
  </div>
</WidgetWrapper>

<script is:inline>
(function () {
  if (window.echarts_init) return;
  window.echarts_init = true;

  const getColors = () => {
    const isDark = document.documentElement.classList.contains('dark');
    return {
      text: isDark ? '#cbd5e1' : '#475569',
      split: isDark ? '#334155' : '#e2e8f0',
      bg: isDark ? 'rgba(30,41,59,0.95)' : 'rgba(255,255,255,0.95)',
      border: isDark ? '#475569' : '#cbd5e1'
    };
  };

  const updateTheme = (chart) => {
    const c = getColors();
    chart.setOption({
      legend: { textStyle: { color: c.text } },
      tooltip: { backgroundColor: c.bg, borderColor: c.border, textStyle: { color: c.text } },
      textStyle: { color: c.text },
      yAxis: [{ splitLine: { lineStyle: { color: c.split } }, nameTextStyle: { color: c.text } }, { nameTextStyle: { color: c.text } }],
      xAxis: { splitLine: { lineStyle: { color: c.split } } }
    });
  };

  const render = async (el) => {
    if (el._echarts) return;
    
    const echarts = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js").then(m => m.default || m);
    const chart = echarts.init(el, null, { renderer: 'canvas' });
    el._echarts = chart;

    const baseOpts = JSON.parse(el.dataset.base || '{}');
    const userOpts = JSON.parse(el.dataset.user || '{}');

    if (baseOpts.tooltip) {
      baseOpts.tooltip.formatter = (params) => {
        const date = new Date(params[0].value[0]).toLocaleDateString();
        let html = `<strong>${date}</strong><br/>`;
        params.forEach(p => {
          const val = p.seriesName.includes('Drawdown') 
            ? Math.abs(p.value[1]).toFixed(2) + '%' 
            : p.value[1].toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          html += `${p.marker} ${p.seriesName}: ${val}<br/>`;
        });
        return html;
      };
    }

    chart.setOption(baseOpts);
    chart.setOption(userOpts);
    updateTheme(chart);

    // Resize Fix: 'width: auto' ist entscheidend für Landscape/Portrait Wechsel
    new ResizeObserver(() => {
        chart.resize({ width: 'auto' });
    }).observe(el);
  };

  const init = () => {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(e => { if(e.isIntersecting) { render(e.target); observer.unobserve(e.target); }});
    }, { rootMargin: '200px' });
    
    document.querySelectorAll('.echart-container').forEach(el => observer.observe(el));

    new MutationObserver((m) => {
      if (m.some(x => x.attributeName === 'class')) {
        document.querySelectorAll('.echart-container').forEach(el => el._echarts && updateTheme(el._echarts));
      }
    }).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
  };

  document.addEventListener('astro:page-load', init);
  if (document.readyState !== 'loading') init();
})();
</script>
