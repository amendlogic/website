---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs';
import path from 'node:path';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options: userOptions,
  csvPath,
  height = '450px',
  id,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

let finalOptions = {};

// -------- 1. Deep Merge Helper --------
function deepMerge(target, source) {
  if (!source) return target;
  const output = { ...target };
  for (const key in source) {
    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
      output[key] = deepMerge(target[key] || {}, source[key]);
    } else {
      output[key] = source[key];
    }
  }
  return output;
}

// -------- 2. CSV Parsing Logic --------
if (csvPath) {
  try {
    const filePath = path.resolve(csvPath);
    const fileContent = fs.readFileSync(filePath, 'utf-8');

    // Zerlegt CSV Zeilen und beachtet Kommas innerhalb von Anführungszeichen
    const rows = fileContent
      .trim()
      .split(/\r?\n/)
      .filter(Boolean)
      .map(row => row.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/));

    const headers = rows[0].map(h => h.trim());

    // Spalten finden
    const idxDate = headers.indexOf('Date/Time');
    const idxProfit = headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%'));
    const idxDD = headers.findIndex(h => h.includes('Drawdown') && h.includes('%'));

    const equityData = [];
    const drawdownData = [];

    // Daten extrahieren
    for (let i = 1; i < rows.length; i++) {
      const row = rows[i];
      const profitVal = row[idxProfit];

      if (profitVal && profitVal.trim() !== '') {
        const rawDate = row[idxDate];
        const d = new Date(rawDate);
        if (isNaN(d.getTime())) continue;

        equityData.push([d.toISOString(), parseFloat(profitVal)]);
        
        const ddVal = parseFloat(row[idxDD] || 0);
        // Drawdown immer negativ speichern
        drawdownData.push([d.toISOString(), Math.abs(ddVal) * -1]);
      }
    }

    // Standard-Optionen
    finalOptions = {
      animationDuration: 1000,
      animationEasing: 'cubicOut',
      grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
      
      tooltip: { 
        trigger: 'axis', 
        axisPointer: { type: 'cross' },
        confine: true
      },

      legend: { 
        data: ['Equity', 'Drawdown %'] 
      },

      xAxis: { 
        type: 'time',
        boundaryGap: false
      },

      yAxis: [
        { 
          type: 'value', 
          name: 'Equity', 
          position: 'left', 
          scale: true,
          splitLine: { show: true } 
        },
        { 
          type: 'value', 
          name: 'Drawdown (%)', 
          position: 'right', 
          min: -100, 
          max: 0, 
          axisLabel: { formatter: '{value}%' }, 
          splitLine: { show: false } 
        }
      ],

      series: [
        { 
          name: 'Equity', 
          type: 'line', 
          sampling: 'lttb',
          smooth: true, 
          showSymbol: false, 
          areaStyle: { opacity: 0.1 }, 
          itemStyle: { color: '#10B981' }, 
          data: equityData 
        },
        { 
          name: 'Drawdown %', 
          type: 'bar', 
          yAxisIndex: 1, 
          itemStyle: { 
            color: '#EF4444',
            opacity: 0.5  // <--- Hier: Transparenz für die Balken
          }, 
          data: drawdownData 
        }
      ]
    };

    if (userOptions) {
      finalOptions = deepMerge(finalOptions, userOptions);
    }

  } catch (e) {
    console.error(`[Chart Error] CSV Parsing failed for ${csvPath}:`, e);
  }
}

const chartId = id ?? `echart-${Math.random().toString(36).slice(2, 11)}`;
const safeOptions = JSON.stringify(finalOptions).replace(/</g, '\\u003c');
---

<WidgetWrapper id={chartId} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />

  {content && (
    <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />
  )}

  <div class="p-4 md:p-6 rounded-md shadow-xl dark:shadow-none dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div
      id={chartId}
      class="echart-container w-full"
      data-chart-options={safeOptions}
      style={`height:${height}; min-height:${height};`}
    ></div>
  </div>
</WidgetWrapper>

<script is:inline>
(function () {
  if (window.echarts_optimized_init) return;
  window.echarts_optimized_init = true;

  let echartsLib = null;
  let resizeObserver = null;
  let themeObserver = null;
  let cleanupFns = [];
  const instances = new Map();

  const getThemeColors = () => {
    const isDark = document.documentElement.classList.contains('dark');
    return {
      text: isDark ? '#cbd5e1' : '#475569',
      axis: isDark ? '#64748b' : '#94a3b8',
      split: isDark ? '#334155' : '#e2e8f0',
      tooltipBg: isDark ? 'rgba(30,41,59,0.95)' : 'rgba(255,255,255,0.95)',
      tooltipBorder: isDark ? '#475569' : '#cbd5e1',
      tooltipText: isDark ? '#f1f5f9' : '#1e293b'
    };
  };

  const applyThemeToChart = (chart, colors) => {
    // 1. Hole aktuelle Optionen, um den Status der Achsen (show: false?) zu kennen
    const currentOpts = chart.getOption();
    
    // Style Definition
    const axisBaseStyle = {
        axisLine: { lineStyle: { color: colors.axis } },
        axisLabel: { color: colors.text },
        nameTextStyle: { color: colors.text }
    };

    // 2. Erstelle dynamisches Y-Achsen-Array basierend auf dem, was da ist
    // Wichtig: Behalte existierende Eigenschaften (wie show, min, max) bei!
    const newYAxis = (currentOpts.yAxis || []).map(axis => ({
        ...axis, // Behalte Einstellungen (z.B. show: false) bei
        ...axisBaseStyle, // Überschreibe nur Farben
        splitLine: { 
            // Behalte show Status bei, ändere nur Farbe
            show: axis.splitLine ? axis.splitLine.show : false, 
            lineStyle: { color: colors.split } 
        }
    }));

    chart.setOption({
      legend: { textStyle: { color: colors.text } },
      tooltip: {
        backgroundColor: colors.tooltipBg,
        borderColor: colors.tooltipBorder,
        textStyle: { color: colors.tooltipText }
      },
      xAxis: {
        axisLine: { lineStyle: { color: colors.axis } },
        axisLabel: { color: colors.text },
        splitLine: { lineStyle: { color: colors.split } }
      },
      yAxis: newYAxis
    });
  };

  async function renderChart(container) {
    if (instances.has(container.id)) return;

    if (!echartsLib) {
      const mod = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js");
      echartsLib = mod.default || mod;
    }

    const chart = echartsLib.init(container, null, { renderer: 'canvas' });
    const options = JSON.parse(container.dataset.chartOptions || '{}');
    
    // Tooltip Formatter wiederherstellen
    if (!options.tooltip) options.tooltip = {};
    options.tooltip.formatter = function (params) {
      const equity = params.find(p => p.seriesName === 'Equity');
      const dd = params.find(p => p.seriesName === 'Drawdown %');

      const dateVal = new Date(params[0].value[0]);
      const dateStr = !isNaN(dateVal) 
        ? dateVal.toLocaleDateString(undefined, { year: 'numeric', month: '2-digit', day: '2-digit' }) 
        : params[0].axisValueLabel;

      let html = `<strong>${dateStr}</strong><br/>`;
      if (equity) {
        html += `Equity: ${equity.value[1].toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}<br/>`;
      }
      if (dd) {
        html += `Drawdown: ${Math.abs(dd.value[1]).toFixed(2)}%`;
      }
      return html;
    };

    chart.setOption(options);
    applyThemeToChart(chart, getThemeColors());

    instances.set(container.id, chart);
    if (resizeObserver) resizeObserver.observe(container);
  }

  function init() {
    const containers = document.querySelectorAll('.echart-container');
    if (!containers.length) return;

    const viewportObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          renderChart(entry.target);
          observer.unobserve(entry.target);
        }
      });
    }, { rootMargin: '200px' });

    containers.forEach(c => viewportObserver.observe(c));

    resizeObserver = new ResizeObserver(entries => {
      entries.forEach(entry => {
        const chart = instances.get(entry.target.id);
        if (chart && !chart.isDisposed()) chart.resize();
      });
    });

    themeObserver = new MutationObserver((mutations) => {
        const isClassMutation = mutations.some(m => m.attributeName === 'class');
        if (isClassMutation) {
            const newColors = getThemeColors();
            instances.forEach(chart => {
                applyThemeToChart(chart, newColors);
            });
        }
    });
    
    themeObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });

    cleanupFns.push(() => {
      viewportObserver.disconnect();
      resizeObserver.disconnect();
      themeObserver.disconnect();
      instances.forEach(c => c.dispose());
      instances.clear();
    });
  }

  const run = () => {
    cleanupFns.forEach(fn => fn());
    cleanupFns = [];
    if (window.requestIdleCallback) window.requestIdleCallback(init);
    else setTimeout(init, 100);
  };

  document.addEventListener('astro:page-load', run);
})();
</script>
