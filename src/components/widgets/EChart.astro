---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs';
import path from 'node:path';

// --- CONFIG ---
const currentLocale = Astro.currentLocale || 'de';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options: userOptions = {},
  csvPath,
  height = '450px',
  id,
  locale = currentLocale,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

const INITIAL_CAPITAL = 300;

// IDs generieren
const uid = Math.random().toString(36).slice(2, 9);
const wrapperId = id ?? `widget-${uid}`;
const chartId = `chart-${uid}`;
const dataId = `data-${uid}`;

let baseOptions = {};

// --- SERVER SIDE PARSING ---
if (csvPath) {
  try {
    const fileContent = fs.readFileSync(path.resolve(csvPath), 'utf-8');
    const lines = fileContent.trim().split(/\r?\n/);

    if (lines.length > 1) {
      const headers = lines[0].split(',').map(h => h.trim());
      const idx = {
        date: headers.indexOf('Date/Time'),
        profit: headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%')),
        dd: headers.findIndex(h => h.includes('Drawdown') && h.includes('%')),
        price: headers.indexOf('Price'),
        contracts: headers.indexOf('Contracts')
      };

      const equity = [];
      const drawdown = [];
      const bnh = [];

      let firstPrice = null;
      let initialContracts = 1;

      for (let i = 1; i < lines.length; i++) {
        const row = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.replace(/"/g, '').trim());
        if (!row[idx.date]) continue;

        const d = new Date(row[idx.date]);
        if (isNaN(d.getTime())) continue;

        const isoDate = d.toISOString();
        const profit = parseFloat(row[idx.profit]);
        const price = parseFloat(row[idx.price]);
        const dd = parseFloat(row[idx.dd]);

        if (!isNaN(profit)) equity.push([isoDate, INITIAL_CAPITAL + profit]);
        if (!isNaN(dd)) drawdown.push([isoDate, -Math.abs(dd)]);

        if (firstPrice === null && !isNaN(price)) {
          firstPrice = price;
          const c = parseFloat(row[idx.contracts]);
          if (!isNaN(c)) initialContracts = c;
          bnh.push([isoDate, INITIAL_CAPITAL]);
        } else if (!isNaN(price)) {
          const bnhProfit = (price - firstPrice) * initialContracts;
          bnh.push([isoDate, INITIAL_CAPITAL + bnhProfit]);
        }
      }

      baseOptions = {
        grid: { left: 0, right: 0, bottom: 0, top: 40, containLabel: true },
        tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, confine: true },
        legend: { data: ['Portfolio Value', 'Buy & Hold', 'Drawdown %'], top: 0 },
        xAxis: { type: 'time', boundaryGap: false },
        yAxis: [
          { type: 'value', scale: true, splitLine: { show: true } },
          { type: 'value', max: 0, splitLine: { show: false }, axisLabel: { formatter: '{value}%' } }
        ],
        series: [
          { 
            name: 'Portfolio Value', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, 
            areaStyle: { opacity: 0.1 }, 
            itemStyle: { color: '#10B981' }, 
            data: equity 
          },
          { 
            name: 'Buy & Hold', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, 
            lineStyle: { type: 'dashed' }, 
            itemStyle: { color: '#94a3b8' }, 
            data: bnh 
          },
          { 
            name: 'Drawdown %', type: 'bar', yAxisIndex: 1, 
            itemStyle: { color: '#EF4444', opacity: 0.5 }, 
            data: drawdown 
          }
        ]
      };
    }
  } catch (e) { console.error(`[EChart CSV Error]: ${e.message}`); }
}
---

<WidgetWrapper id={wrapperId} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />
  {content && <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />}

  <div class="p-4 md:p-6 rounded-md shadow-xl dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div 
      id={chartId} 
      data-json-id={dataId}
      class="echart-container w-full overflow-hidden" 
      style={`height:${height};`}
    ></div>
  </div>
</WidgetWrapper>

<script type="application/json" id={dataId} set:html={JSON.stringify({ baseOptions, userOptions, locale })} />

<script is:inline>
(() => {
  const chartMap = new Map();
  let resizeObserver;
  let intersectionObserver;
  let mutationObserver;

  const getThemeColors = () => {
    const dark = document.documentElement.classList.contains('dark');
    return {
      text: dark ? '#cbd5e1' : '#475569',
      split: dark ? '#334155' : '#e2e8f0',
      bg: dark ? 'rgba(30,41,59,0.95)' : 'rgba(255,255,255,0.95)',
      border: dark ? '#475569' : '#cbd5e1'
    };
  };

  const applyTheme = (chart) => {
    const c = getThemeColors();
    chart.setOption({
      textStyle: { color: c.text },
      legend: { textStyle: { color: c.text } },
      tooltip: { backgroundColor: c.bg, borderColor: c.border, textStyle: { color: c.text } },
      xAxis: { splitLine: { lineStyle: { color: c.split } } },
      yAxis: [{ splitLine: { lineStyle: { color: c.split } } }, {}]
    });
  };

  const renderChart = async (el) => {
    if (el.getAttribute('data-loaded') === 'true') return;

    const jsonId = el.getAttribute('data-json-id');
    const dataScript = document.getElementById(jsonId);
    if (!dataScript) return;

    let config;
    try { config = JSON.parse(dataScript.textContent); } catch (e) { return; }

    const { baseOptions, userOptions, locale } = config;
    if (!baseOptions || Object.keys(baseOptions).length === 0) return;

    const echarts = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js")
      .then(m => m.default || m);

    const chart = echarts.init(el);

    // 1. ACHSEN FORMATTER (FIX: Nutzt 'en-US' für k/M Notation)
    const axisFormatter = new Intl.NumberFormat('en-US', {
      notation: "compact",
      maximumFractionDigits: 1
    });

    if (baseOptions.yAxis && baseOptions.yAxis[0]) {
      // Wir müssen die Achse neu definieren, da JSON Funktionen löscht
      baseOptions.yAxis[0].axisLabel = {
        formatter: (val) => axisFormatter.format(val)
      };
    }

    // 2. TOOLTIP FORMATTER (Nutzt User-Locale für Datum)
    if (baseOptions.tooltip) {
      baseOptions.tooltip.formatter = (params) => {
        const date = new Date(params[0].value[0]).toLocaleDateString(locale);
        let html = `<strong>${date}</strong><br/>`;
        params.forEach(p => {
          let val;
          if (p.seriesName.includes('Drawdown')) {
             val = Math.abs(p.value[1]).toFixed(2) + '%';
          } else {
             // Währung normal formatiert (de-DE macht 1.000,00)
             val = p.value[1].toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          }
          html += `${p.marker} ${p.seriesName}: ${val}<br/>`;
        });
        return html;
      };
    }

    chart.setOption(baseOptions);
    chart.setOption(userOptions);
    applyTheme(chart);

    chartMap.set(el, chart);
    el.setAttribute('data-loaded', 'true');
  };

  const init = () => {
    cleanup();

    resizeObserver = new ResizeObserver(entries => {
      entries.forEach(e => {
        const chart = chartMap.get(e.target);
        if (chart) chart.resize({ width: 'auto' });
      });
    });

    intersectionObserver = new IntersectionObserver((entries, obs) => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          renderChart(e.target);
          obs.unobserve(e.target);
          resizeObserver.observe(e.target);
        }
      });
    }, { rootMargin: "200px" });

    mutationObserver = new MutationObserver((m) => {
      if (m.some(x => x.attributeName === 'class')) {
        chartMap.forEach(chart => applyTheme(chart));
      }
    });
    mutationObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });

    document.querySelectorAll('.echart-container').forEach(el => {
      intersectionObserver.observe(el);
    });
  };

  const cleanup = () => {
    chartMap.forEach(c => c.dispose());
    chartMap.clear();
    if (resizeObserver) resizeObserver.disconnect();
    if (intersectionObserver) intersectionObserver.disconnect();
    if (mutationObserver) mutationObserver.disconnect();
    document.querySelectorAll('.echart-container').forEach(el => el.removeAttribute('data-loaded'));
  };

  document.addEventListener('astro:page-load', init);
  document.addEventListener('astro:before-swap', cleanup);

  if (document.readyState !== 'loading') init();

})();
</script>
