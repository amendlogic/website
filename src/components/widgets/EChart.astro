<script is:inline>
  (function() {
    if (window.echarts_optimized_init) return;
    window.echarts_optimized_init = true;

    // --- 1. KONFIGURATION MIT CSS VARIABLEN ---
    // Hier definierst du nur die Variablennamen aus deiner CSS-Datei
    const GLOBAL_CONFIG = {
      fontFamily: "'Inter', sans-serif",
      textColorVar: '--aw-color-text-muted',  // Die Haupt-Textfarbe
      gridColorVar: '--aw-color-text-muted',  // Ggf. eine schwächere Farbe für Linien (z.B. border)
      // Tipp: Für Grid Lines könntest du auch opacity nutzen oder eine eigene Variable definieren
    };

    let echartsLib = null;
    let resizeObserver = null;
    let cleanupFns = [];
    const instances = new Map();

    // --- HELPER: CSS Variable auslesen ---
    // Wandelt '--aw-color-text-muted' in 'rgb(r,g,b)' um
    const getCSS = (varName) => {
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    };

    async function renderChart(container) {
      if (instances.has(container.id)) return;

      try {
        if (!echartsLib) {
          const mod = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js");
          echartsLib = mod.default || mod;
        }

        const chart = echartsLib.init(container, null, { renderer: 'canvas' });
        const datasetOptions = JSON.parse(container.dataset.chartOptions || '{}');
        
        // Farben jetzt dynamisch abrufen
        const textColor = getCSS(GLOBAL_CONFIG.textColorVar);
        const gridColor = getCSS(GLOBAL_CONFIG.gridColorVar); // Oder textColor mit Opacity nutzen

        // --- BASIS OPTIONS ---
        const baseOptions = {
          textStyle: {
            fontFamily: GLOBAL_CONFIG.fontFamily,
            fontSize: 13,
            color: textColor,
          },
          title: {
            textStyle: { color: textColor, fontWeight: '600' }
          },
          legend: {
            textStyle: { color: textColor }
          },
          // Grid-Lines mit reduzierter Deckkraft (damit sie nicht so hart sind wie Text)
          xAxis: {
            axisLine: { lineStyle: { color: gridColor, opacity: 0.2 } },
            axisLabel: { color: textColor, opacity: 0.8 },
            splitLine: { lineStyle: { color: gridColor, opacity: 0.1 } }
          },
          yAxis: {
            axisLine: { lineStyle: { color: gridColor, opacity: 0.2 } },
            axisLabel: { color: textColor, opacity: 0.8 },
            splitLine: { lineStyle: { color: gridColor, opacity: 0.1 } }
          },
          tooltip: {
            backgroundColor: getComputedStyle(document.body).backgroundColor, // Passt sich Background an
            borderColor: gridColor,
            textStyle: { color: textColor, fontFamily: GLOBAL_CONFIG.fontFamily }
          }
        };

        chart.setOption(baseOptions);
        chart.setOption(datasetOptions);
        instances.set(container.id, chart);

        if (resizeObserver) resizeObserver.observe(container);

      } catch (e) {
        console.error("Chart Render Error:", e);
      }
    }

    function init() {
      const containers = document.querySelectorAll('.echart-container');
      if (containers.length === 0) return;

      resizeObserver = new ResizeObserver((entries) => {
        entries.forEach(entry => {
          const chart = instances.get(entry.target.id);
          if (chart && !chart.isDisposed()) {
            chart.resize({ width: 'auto', animation: { duration: 0 } });
          }
        });
      });

      const viewportObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            renderChart(entry.target);
            observer.unobserve(entry.target);
          }
        });
      }, { rootMargin: '200px' });

      containers.forEach(c => viewportObserver.observe(c));

      cleanupFns.push(() => {
        viewportObserver.disconnect();
        resizeObserver.disconnect();
        instances.forEach(c => c.dispose());
        instances.clear();
      });
    }

    const run = () => {
      cleanupFns.forEach(fn => fn());
      cleanupFns = [];
      if (window.requestIdleCallback) window.requestIdleCallback(init);
      else setTimeout(init, 100);
    };

    document.addEventListener('astro:page-load', run);
  })();
</script>
