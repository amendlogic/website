---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options,
  height = '400px',
  id,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

const chartId = `echart-${Math.random().toString(36).slice(2, 11)}`;
---

<WidgetWrapper id={id} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />

  {content && <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />}

  <div class="p-4 md:p-6 rounded-md shadow-xl dark:shadow-none dark:border dark:border-slate-600">
    <div 
      id={chartId} 
      class="echart-container" 
      data-chart-options={JSON.stringify(options)} 
      style={`width:100%; height:${height};`}
    ></div>
  </div>
</WidgetWrapper>

<script is:inline>
  (function() {
    let echartsModule;
    const chartInstances = new Map(); // Speichert Instanzen pro Container-ID

    // Performance-Helper: Debounce
    const debounce = (fn, delay) => {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), delay);
      };
    };

    async function initCharts() {
      const containers = document.querySelectorAll('.echart-container');
      if (containers.length === 0) return;

      // 1. ECharts erst laden, wenn der Browser im Leerlauf ist
      if (!echartsModule) {
        echartsModule = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js");
      }

      containers.forEach((container) => {
        const id = container.id;
        
        // Alte Instanz aufräumen
        if (chartInstances.has(id)) {
          chartInstances.get(id).dispose();
          chartInstances.delete(id);
        }

        // 2. Initialisierung in einem RequestAnimationFrame, um Frame-Drops zu vermeiden
        requestAnimationFrame(() => {
          const chart = echartsModule.init(container);
          const options = JSON.parse(container.dataset.chartOptions || '{}');
          chart.setOption(options);
          chartInstances.set(id, chart);
        });
      });

      // 3. Hochperformanter Resize-Handler
      const handleResize = debounce(() => {
        chartInstances.forEach((chart) => {
          if (chart && !chart.isDisposed()) {
            // Resize mit kleiner Animation für flüssige Optik
            chart.resize({ animation: { duration: 200 } });
          }
        });
      }, 150); // Genügend Zeit für das CSS-Layout (Textgrößen) lassen

      window.addEventListener('resize', handleResize);

      // Cleanup bei Astro View-Transitions
      document.addEventListener('astro:before-swap', () => {
        window.removeEventListener('resize', handleResize);
        chartInstances.forEach(chart => chart.dispose());
        chartInstances.clear();
      }, { once: true });
    }

    // --- Start-Logik ---
    // Wir nutzen requestIdleCallback, damit ECharts niemals das erste Rendern verzögert
    const startLogic = () => {
      if (window.requestIdleCallback) {
        window.requestIdleCallback(() => initCharts());
      } else {
        setTimeout(initCharts, 200);
      }
    };

    document.addEventListener('astro:page-load', startLogic);
  })();
</script>
