---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs';
import path from 'node:path';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  csvPath,
  height = '450px',
  id,
  classes = {},
} = Astro.props;

const INITIAL_CAPITAL = 300;
let baseOptions = {};

// --- SERVER SIDE: CSV PARSING (Dein sauberer Code + Farben) ---
if (csvPath) {
  try {
    const file = fs.readFileSync(path.resolve(csvPath), 'utf-8');
    const lines = file.trim().split(/\r?\n/);
    if (lines.length < 2) throw new Error('CSV empty');

    const headers = lines[0].split(',');
    const idx = {
      date: headers.indexOf('Date/Time'),
      profit: headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%')),
      dd: headers.findIndex(h => h.includes('Drawdown') && h.includes('%')),
      price: headers.indexOf('Price'),
      contracts: headers.indexOf('Contracts')
    };

    const equity = [];
    const dd = [];
    const bnh = [];

    let firstPrice = null;
    let initialContracts = 1;

    for (let i = 1; i < lines.length; i++) {
      // Regex Split für CSV (Wichtig für Kommas in Zahlen)
      const row = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      if (row.length < headers.length) continue;

      const rawDate = row[idx.date];
      if (!rawDate) continue;

      const d = new Date(rawDate.replace(' ', 'T'));
      if (isNaN(d.getTime())) continue;

      const iso = d.toISOString();
      const profit = parseFloat(row[idx.profit] || 0);
      const price = parseFloat(row[idx.price] || 0);
      const drawdown = parseFloat(row[idx.dd] || 0);

      equity.push([iso, INITIAL_CAPITAL + profit]);
      dd.push([iso, -Math.abs(drawdown)]);

      if (firstPrice === null && !isNaN(price)) {
        firstPrice = price;
        const c = parseFloat(row[idx.contracts]);
        if (!isNaN(c) && c > 0) initialContracts = c;
        bnh.push([iso, INITIAL_CAPITAL]);
      } else if (firstPrice !== null && !isNaN(price)) {
        bnh.push([iso, INITIAL_CAPITAL + (price - firstPrice) * initialContracts]);
      }
    }

    baseOptions = {
      animation: false,
      grid: { left: 0, right: 0, bottom: 0, top: 30, containLabel: true },
      tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, confine: true },
      legend: { data: ['Portfolio Value', 'Buy & Hold', 'Drawdown %'], top: 0 },
      xAxis: { type: 'time', boundaryGap: false },
      yAxis: [
        { type: 'value', scale: true, splitLine: { show: true } },
        { type: 'value', max: 0, splitLine: { show: false }, axisLabel: { formatter: '{value}%' } }
      ],
      series: [
        {
          name: 'Portfolio Value',
          type: 'line',
          sampling: 'lttb',
          smooth: 0.2,
          showSymbol: false,
          areaStyle: { opacity: 0.1 },
          itemStyle: { color: '#10B981' }, // HIER: AstroWind Grün wieder eingefügt
          data: equity
        },
        {
          name: 'Buy & Hold',
          type: 'line',
          sampling: 'lttb',
          smooth: 0.2,
          showSymbol: false,
          lineStyle: { type: 'dashed' },
          itemStyle: { color: '#94a3b8' }, // HIER: Neutrales Grau
          data: bnh
        },
        {
          name: 'Drawdown %',
          type: 'bar',
          yAxisIndex: 1,
          itemStyle: { color: '#EF4444', opacity: 0.9 }, // HIER: AstroWind Rot
          data: dd
        }
      ]
    };

  } catch (e) {
    console.error('[Chart Error]', e.message);
  }
}

const chartId = id ?? `echart-${Math.random().toString(36).slice(2, 9)}`;
---

<WidgetWrapper containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />
  {content && <div class="mb-10" set:html={content} />}
  
  <div class="bg-white dark:bg-slate-900 rounded-lg shadow-xl dark:shadow-none dark:border dark:border-slate-600">
    <div
      id={chartId}
      class="echart-container w-full overflow-hidden p-4 md:p-6"
      data-base={JSON.stringify(baseOptions)}
      style={`height:${height}`}
    ></div>
  </div>
</WidgetWrapper>

<script is:inline>
(() => {
  let echartsLib;

  // Lazy Load Funktion
  const loadEcharts = async () => {
    if (echartsLib) return echartsLib;
    echartsLib = await import("https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.esm.min.js")
      .then(m => m.default || m);
    return echartsLib;
  };

  // HIER: Die lebenswichtige Theme-Logik (AstroWind Farben)
  const getThemeColors = () => {
    const isDark = document.documentElement.classList.contains('dark');
    return {
      text: isDark ? '#cbd5e1' : '#475569',      // Hellgrau im Darkmode, Dunkel im Lightmode
      split: isDark ? '#334155' : '#e2e8f0',
      bg: isDark ? 'rgba(30,41,59,0.95)' : 'rgba(255,255,255,0.95)',
      border: isDark ? '#475569' : '#cbd5e1'
    };
  };

  const updateChartTheme = (chart) => {
    const c = getThemeColors();
    chart.setOption({
      legend: { textStyle: { color: c.text } },
      tooltip: { backgroundColor: c.bg, borderColor: c.border, textStyle: { color: c.text } },
      textStyle: { color: c.text }, // Das färbt alle Achsenbeschriftungen auf einen Schlag!
      yAxis: [{ splitLine: { lineStyle: { color: c.split } } }, {}],
      xAxis: { splitLine: { lineStyle: { color: c.split } } }
    });
  };

  const render = async (el) => {
    if (el._chart) return;

    const echarts = await loadEcharts();
    const chart = echarts.init(el, null, { renderer: 'canvas' });
    el._chart = chart;

    const base = JSON.parse(el.dataset.base || '{}');

    // 1. Dein cleaner Formatter (10k, 1.5M)
    const compact = new Intl.NumberFormat('en-US', { notation: 'compact', maximumFractionDigits: 1 });
    if (base.yAxis && base.yAxis[0]) {
      base.yAxis[0].axisLabel = { formatter: v => compact.format(v) };
    }

    // 2. Tooltip Formatter
    if (base.tooltip) {
      base.tooltip.formatter = (params) => {
        const date = new Date(params[0].value[0]).toLocaleDateString();
        let html = `<strong>${date}</strong><br/>`;
        for (const p of params) {
          const val = p.seriesName.includes('Drawdown')
            ? Math.abs(p.value[1]).toFixed(2) + '%'
            : p.value[1].toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          html += `${p.marker} ${p.seriesName}: ${val}<br/>`;
        }
        return html;
      };
    }

    chart.setOption(base);
    updateChartTheme(chart); // Farben sofort beim Start setzen

    // Resize Fix: 'width: auto' ist wichtig für Landscape/Portrait Wechsel
    new ResizeObserver(() => chart.resize({ width: 'auto' })).observe(el);
  };

  const init = () => {
    // 1. Intersection Observer (Lazy Loading)
    const observer = new IntersectionObserver((entries, obs) => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          render(e.target);
          obs.unobserve(e.target);
        }
      });
    }, { rootMargin: '200px' });

    document.querySelectorAll('.echart-container').forEach(el => observer.observe(el));

    // 2. Theme Observer (WICHTIG! Sonst keine Anpassung bei Dark Mode Toggle)
    new MutationObserver((m) => {
      if (m.some(x => x.attributeName === 'class')) {
        document.querySelectorAll('.echart-container').forEach(el => el._chart && updateChartTheme(el._chart));
      }
    }).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
  };

  document.addEventListener('astro:page-load', init);
  if (document.readyState !== 'loading') init();

})();
</script>