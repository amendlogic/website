---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options,
  height = '400px',
  id,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

const chartId = `echart-${Math.random().toString(36).slice(2, 11)}`;
---

<WidgetWrapper id={id} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />

  {content && <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />}

  <div class="p-4 md:p-6 rounded-md shadow-xl dark:shadow-none dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div 
      id={chartId} 
      class="echart-container" 
      data-chart-options={JSON.stringify(options)} 
      style={`width:100%; height:${height}; min-height:${height};`}
    ></div>
  </div>
</WidgetWrapper>

<script is:inline>
  (function() {
    // Singleton-Check (verhindert doppelte Ausführung)
    if (window.echarts_optimized_init) return;
    window.echarts_optimized_init = true;

    let echartsLib = null; // Speichert die geladene Library
    let resizeObserver = null;
    let cleanupFns = [];
    const instances = new Map();

    // --- 1. RENDER FUNKTION ---
    async function renderChart(container) {
      if (instances.has(container.id)) return;

      try {
        // Library nur laden, wenn noch nicht da
        if (!echartsLib) {
          const mod = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js");
          // WICHTIG: Fallback für Module-Export-Typen (fixiert das "Loading..." Problem)
          echartsLib = mod.default || mod;
        }

        const chart = echartsLib.init(container, null, { renderer: 'canvas' });
        const options = JSON.parse(container.dataset.chartOptions || '{}');
        
        // Theme-Anpassung (Dark Mode Support)
        const isDark = document.documentElement.classList.contains('dark');
        if (isDark && !options.backgroundColor) {
          options.backgroundColor = 'transparent';
          if (!options.textStyle) options.textStyle = {};
          options.textStyle.color = '#cbd5e1'; // slate-300
        }

        chart.setOption(options);
        instances.set(container.id, chart);

        // Performance: Resize Observer für diesen Container registrieren
        if (resizeObserver) resizeObserver.observe(container);

      } catch (e) {
        console.error("Chart Render Error:", e);
      }
    }

    // --- 2. START LOGIK (Intersection Observer) ---
    // Lädt ECharts NUR wenn das Element sichtbar wird -> PageSpeed Boost!
    function init() {
      const containers = document.querySelectorAll('.echart-container');
      if (containers.length === 0) return;

      // Zentraler Resize Observer (Memory effizient)
      resizeObserver = new ResizeObserver((entries) => {
        // requestAnimationFrame verhindert "Layout Thrashing"
        window.requestAnimationFrame(() => {
          entries.forEach(entry => {
            const chart = instances.get(entry.target.id);
            if (chart && !chart.isDisposed()) {
              chart.resize();
            }
          });
        });
      });

      // Viewport Observer (Lazy Load)
      const viewportObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            renderChart(entry.target);
            observer.unobserve(entry.target); // Sofort aufhören zu beobachten
          }
        });
      }, { rootMargin: '200px' }); // Lädt 200px bevor es sichtbar wird

      containers.forEach(c => viewportObserver.observe(c));

      // Cleanup registrieren
      cleanupFns.push(() => {
        viewportObserver.disconnect();
        resizeObserver.disconnect();
        instances.forEach(c => c.dispose());
        instances.clear();
      });
    }

    // --- 3. LIFECYCLE ---
    const run = () => {
      // Aufräumen alter Instanzen (Memory Leak Prevention)
      cleanupFns.forEach(fn => fn());
      cleanupFns = [];

      // Starten wenn Browser Zeit hat
      if (window.requestIdleCallback) {
        window.requestIdleCallback(init);
      } else {
        setTimeout(init, 100);
      }
    };

    // Astro Event Listener
    document.addEventListener('astro:page-load', run);
    
    // Theme Switch Listener (Optional: Passt Farben beim Umschalten an)
    const themeObserver = new MutationObserver((mutations) => {
      if (instances.size > 0 && mutations[0].attributeName === 'class') {
         const isDark = document.documentElement.classList.contains('dark');
         instances.forEach(chart => {
            chart.setOption({ 
              textStyle: { color: isDark ? '#cbd5e1' : '#475569' } 
            });
         });
      }
    });
    themeObserver.observe(document.documentElement, { attributes: true });

  })();
</script>
