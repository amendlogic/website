---
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Headline from '~/components/ui/Headline.astro';
import fs from 'node:fs';
import path from 'node:path';

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  options: userOptions = {},
  csvPath,
  height = '450px',
  id,
  locale = 'de-DE',
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

const INITIAL_CAPITAL = 300;

const wrapperId = id ?? `widget-${crypto.randomUUID()}`;
const chartId = `chart-${wrapperId}`;
const dataId = `chart-data-${wrapperId}`;

let baseOptions = {};

if (csvPath) {
  try {
    const fileContent = fs.readFileSync(path.resolve(csvPath), 'utf-8');
    const lines = fileContent.trim().split(/\r?\n/);

    if (lines.length > 1) {
      const headers = lines[0].split(',').map(h => h.trim());

      const idx = {
        date: headers.indexOf('Date/Time'),
        profit: headers.findIndex(h => h.includes('Cum. Profit') && !h.includes('%')),
        dd: headers.findIndex(h => h.includes('Drawdown') && h.includes('%')),
        price: headers.indexOf('Price'),
        contracts: headers.indexOf('Contracts')
      };

      const equity = [];
      const drawdown = [];
      const bnh = [];

      let firstPrice = null;
      let initialContracts = 1;

      for (let i = 1; i < lines.length; i++) {
        const row = lines[i]
          .split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/)
          .map(v => v.replace(/"/g, '').trim());

        if (!row[idx.date]) continue;

        const d = new Date(row[idx.date]);
        if (isNaN(d)) continue;

        const isoDate = d.toISOString();
        const profit = parseFloat(row[idx.profit]);
        const price = parseFloat(row[idx.price]);
        const dd = parseFloat(row[idx.dd]);

        if (!isNaN(profit))
          equity.push([isoDate, INITIAL_CAPITAL + profit]);

        if (!isNaN(dd))
          drawdown.push([isoDate, -Math.abs(dd)]);

        if (firstPrice === null && !isNaN(price)) {
          firstPrice = price;
          const c = parseFloat(row[idx.contracts]);
          if (!isNaN(c)) initialContracts = c;
          bnh.push([isoDate, INITIAL_CAPITAL]);
        } else if (!isNaN(price)) {
          const bnhProfit = (price - firstPrice) * initialContracts;
          bnh.push([isoDate, INITIAL_CAPITAL + bnhProfit]);
        }
      }

      baseOptions = {
        grid: { left: 0, right: 0, bottom: 0, containLabel: true },
        tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, confine: true },
        legend: { data: ['Portfolio Value', 'Buy & Hold', 'Drawdown %'], top: 0 },
        xAxis: { type: 'time', boundaryGap: false },
        yAxis: [
          { type: 'value', scale: true },
          { type: 'value', max: 0 }
        ],
        series: [
          { name: 'Portfolio Value', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, data: equity },
          { name: 'Buy & Hold', type: 'line', sampling: 'lttb', smooth: true, showSymbol: false, lineStyle: { type: 'dashed' }, data: bnh },
          { name: 'Drawdown %', type: 'bar', yAxisIndex: 1, data: drawdown }
        ]
      };
    }
  } catch (e) {
    console.error(`[EChart CSV Error]: ${e.message}`);
  }
}
---

<WidgetWrapper id={wrapperId} isDark={isDark} containerClass={`max-w-6xl mx-auto ${classes?.container ?? ''}`} bg={bg}>
  <Headline title={title} subtitle={subtitle} tagline={tagline} />
  {content && <div class="mb-12 text-lg dark:text-slate-400" set:html={content} />}

  <div class="p-4 md:p-6 rounded-md shadow-xl dark:border dark:border-slate-600 bg-white dark:bg-slate-900">
    <div id={chartId} class="echart-container w-full" style={`height:${height};`}></div>
  </div>
</WidgetWrapper>

<script type="application/json" id={dataId}>
  {JSON.stringify({ baseOptions, userOptions, locale })}
</script>

<script is:inline>
(() => {

  let charts = new Set();
  let resizeObserver;
  let intersectionObserver;

  const getThemeColors = () => {
    const dark = document.documentElement.classList.contains('dark');
    return {
      text: dark ? '#cbd5e1' : '#475569',
      split: dark ? '#334155' : '#e2e8f0'
    };
  };

  const applyTheme = (chart) => {
    const c = getThemeColors();
    chart.setOption({
      textStyle: { color: c.text },
      legend: { textStyle: { color: c.text } },
      xAxis: { splitLine: { lineStyle: { color: c.split } } },
      yAxis: [{ splitLine: { lineStyle: { color: c.split } } }, {}]
    });
  };

  const renderChart = async (el) => {
    if (el.dataset.initialized) return;

    const dataScript = document.querySelector(`#chart-data-${el.id.replace('chart-','')}`);
    if (!dataScript) return;

    const { baseOptions, userOptions, locale } = JSON.parse(dataScript.textContent);

    const echarts = await import("https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.esm.min.js")
      .then(m => m.default || m);

    const chart = echarts.init(el);

    const numberFormatter = new Intl.NumberFormat(locale, {
      notation: "compact",
      maximumFractionDigits: 1
    });

    if (baseOptions.yAxis?.[0]) {
      baseOptions.yAxis[0].axisLabel = {
        formatter: val => numberFormatter.format(val)
      };
    }

    chart.setOption(baseOptions);
    chart.setOption(userOptions);
    applyTheme(chart);

    charts.add(chart);
    el.dataset.initialized = "true";
  };

  const init = () => {
    resizeObserver = new ResizeObserver(entries => {
      entries.forEach(e => {
        const chart = charts.values().next().value;
        if (chart) chart.resize();
      });
    });

    intersectionObserver = new IntersectionObserver((entries, obs) => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          renderChart(e.target);
          obs.unobserve(e.target);
        }
      });
    }, { rootMargin: "200px" });

    document.querySelectorAll('.echart-container').forEach(el => {
      intersectionObserver.observe(el);
      resizeObserver.observe(el);
    });
  };

  document.addEventListener('astro:page-load', init);
  document.addEventListener('astro:before-swap', () => {
    charts.forEach(c => c.dispose());
    charts.clear();
  });

  if (document.readyState !== 'loading') init();

})();
</script>