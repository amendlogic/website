---
import { UI } from 'astrowind:config';
---

<script is:inline define:vars={{ defaultTheme: UI.theme || 'system' }}>
  if (window.basic_script_init) return;
  window.basic_script_init = true;

  (function() {
    let cleanupFns = [];
    
    // Variablen für DOM-Elemente
    let header, menuBtn, nav, stickyHeader;

    // --- DOM ELEMENTE HOLEN (Muss bei jedem Swap laufen) ---
    const initDom = () => {
      header = document.getElementById('header');
      menuBtn = header?.querySelector('[data-aw-toggle-menu]');
      nav = header?.querySelector('nav');
      stickyHeader = header?.querySelector('[data-aw-sticky-header]');
    };

    const toggleClass = (el, className, condition) => {
      if(el) el.classList.toggle(className, !!condition);
    };

    const applyTheme = (theme) => {
      const resolved = theme === 'system'
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
        : theme;
      document.documentElement.dataset.theme = resolved;
      toggleClass(document.documentElement, 'dark', resolved === 'dark');
      if(menuBtn){
        const icons = menuBtn.querySelectorAll('svg,[data-aw-icon]');
        if(icons.length>1) icons[0].classList.toggle('hidden', resolved==='dark');
      }
    };

    // --- HEADER ---
    const initHeader = () => {
      if(!stickyHeader) return;
      let lastState = window.scrollY > 60;
      toggleClass(stickyHeader,'scroll',lastState);

      const onScroll = ()=>{
        const isScrolled = window.scrollY > 60;
        if(isScrolled!==lastState){
          toggleClass(stickyHeader,'scroll',isScrolled);
          lastState = isScrolled;
        }
      };
      window.addEventListener('scroll',onScroll,{passive:true});
      cleanupFns.push(()=>window.removeEventListener('scroll',onScroll));
    };

    // --- MENU ---
    const initMenu = () => {
      if(!menuBtn || !nav) return;

      const toggleMenu = ()=>{
        const isExpanded = menuBtn.classList.toggle('expanded');
        document.body.classList.toggle('overflow-hidden', isExpanded);
        header.classList.toggle('h-screen', isExpanded);
        header.classList.toggle('expanded', isExpanded);
        header.classList.toggle('bg-page', isExpanded);
        
        // Icons
        const icons = menuBtn.querySelectorAll('svg,[data-aw-icon]');
        if(icons.length>1){
            icons[0].classList.toggle('hidden', isExpanded);
            icons[1].classList.toggle('hidden', !isExpanded);
        }

        nav.classList.toggle('hidden');
        const actions = header.querySelector('nav + div, div > div:last-child');
        if(actions) actions.classList.toggle('hidden', !isExpanded);
      };

      // Globale Funktion zum Schließen registrieren (wie im Original)
      window.closeMenuInstance = ()=>{ if(menuBtn.classList.contains('expanded')) toggleMenu(); };

      menuBtn.addEventListener('click', toggleMenu);
      cleanupFns.push(()=>menuBtn.removeEventListener('click', toggleMenu));

      // Dropdown
      const onNavClick = (e)=>{
        const trigger = e.target.closest('.dropdown > button, .dropdown > a');
        if(!trigger || window.getComputedStyle(menuBtn).display==='none') return;
        e.preventDefault();
        const subMenu = trigger.nextElementSibling;
        if(subMenu){
            const expanded = subMenu.classList.toggle('hidden')===false;
            trigger.classList.toggle('expanded', expanded);
        }
      };
      nav.addEventListener('click', onNavClick);
      cleanupFns.push(()=>nav.removeEventListener('click', onNavClick));
    };

    // --- GLOBAL EVENTS (MIT DEINER ORIGINAL LOGIK) ---
    const initGlobalEvents = ()=>{
      const onClick = (e)=>{
        // Theme
        const themeBtn = e.target.closest('[data-aw-toggle-color-scheme]');
        if(themeBtn){
            const themes = ['system','light','dark'];
            const current = localStorage.getItem('theme')||'system';
            const next = themes[(themes.indexOf(current)+1)%3];
            localStorage.setItem('theme',next);
            applyTheme(next);
            return;
        }

        // --- ORIGINAL SMOOTH SCROLL LOGIK ---
        const link = e.target.closest('a');
        if(!link || !link.hash || link.origin!==location.origin || link.pathname!==location.pathname) return;

        const targetEl = document.querySelector(link.hash);
        if(!targetEl) return;

        e.preventDefault();
        // link.blur() war im Original wichtig für Mobile Tastaturen/Focus
        link.blur();

        // Menü schließen falls offen (Original Logik)
        if(header?.classList.contains('expanded') && window.closeMenuInstance){
            window.closeMenuInstance();
        }

        // Delay wie im Original, damit Mobile Layout sich stabilisiert
        setTimeout(()=>{
            const headerHeight = header?.getBoundingClientRect().height||0;
            const targetPos = targetEl.getBoundingClientRect().top + window.scrollY;

            // CSS Smooth Scroll: zuverlässig auf Mobile
            window.scrollTo({ top: targetPos - headerHeight, behavior:'smooth' });

            history.pushState(null,null,link.hash);
        }, 50);
        // --- ENDE ORIGINAL LOGIK ---
      };

      document.addEventListener('click',onClick,{capture:true,passive:false});
      cleanupFns.push(()=>document.removeEventListener('click',onClick,{capture:true}));
    };

    // --- ANIMATIONS ---
    const initAnimations = ()=>{
      const selectors = ['[class*=" intersect:"]','[class*=":intersect:"]','[class^="intersect:"]','[class="intersect"]','.intersect-once','.intersect-quarter'];
      const elements = document.querySelectorAll(selectors.join(','));
      if(!elements.length) return;

      const observer = new IntersectionObserver((entries)=>{
        entries.forEach(entry=>{
          if(entry.isIntersecting){
            entry.target.setAttribute('data-aw-animated','true');
            if(entry.target.classList.contains('intersect-once')) observer.unobserve(entry.target);
          }
        });
      },{threshold:0.1});

      elements.forEach(el=>observer.observe(el));
      cleanupFns.push(()=>observer.disconnect());
    };

    // --- MAIN ---
    const run = ()=>{
      cleanupFns.forEach(fn=>fn());
      cleanupFns=[];

      initDom(); // WICHTIG: Holt neue Elemente nach View Transition
      applyTheme(localStorage.getItem('theme')||'system');
      initHeader();
      initMenu();
      setTimeout(initGlobalEvents,0);
      
      if(window.requestIdleCallback) window.requestIdleCallback(initAnimations);
      else setTimeout(initAnimations,200);
    };

    run();
    document.addEventListener('astro:after-swap', run);
  })();
</script>
