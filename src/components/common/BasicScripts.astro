---
import { UI } from 'astrowind:config';
---

<script is:inline define:vars={{ defaultTheme: UI.theme || 'system' }}>
  // Singleton: Verhindert doppelte Ausführung
  if (window.basic_script_init) return;
  window.basic_script_init = true;

  (function() {
    let cleanupFns = [];

    // --- HELPER ---
    const getHeaderHeight = () => {
      const header = document.getElementById('header');
      return header ? header.getBoundingClientRect().height : 0;
    };

    // --- THEME ---
    const applyTheme = (theme) => {
      const resolvedTheme = (theme === 'system') 
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') 
        : theme;
      
      requestAnimationFrame(() => {
        if (resolvedTheme === 'dark') document.documentElement.classList.add('dark');
        else document.documentElement.classList.remove('dark');
        
        document.querySelectorAll('[data-aw-theme-icon]').forEach((icon) => {
          if (icon.getAttribute('data-aw-theme-icon') === theme) icon.classList.remove('hidden');
          else icon.classList.add('hidden');
        });
      });
    };

    const initTheme = () => {
      const stored = localStorage.getItem('theme') || defaultTheme;
      applyTheme(stored);
    };

    // --- 1. HEADER SCROLL STATE ---
    const initHeader = () => {
      const header = document.getElementById('header');
      const stickyHeader = document.querySelector('#header[data-aw-sticky-header]');
      if (!stickyHeader) return;

      let isTicking = false;
      const onScroll = () => {
        if (!isTicking) {
          window.requestAnimationFrame(() => {
            stickyHeader.classList.toggle('scroll', window.scrollY > 10);
            isTicking = false;
          });
          isTicking = true;
        }
      };

      window.addEventListener('scroll', onScroll, { passive: true });
      if (window.scrollY > 10) stickyHeader.classList.add('scroll');
      cleanupFns.push(() => window.removeEventListener('scroll', onScroll));
    };

    // --- 2. MENU & DROPDOWN LOGIK (STRICT CLOSE) ---
    const initMenu = () => {
      const header = document.getElementById('header');
      const menuBtn = document.querySelector('[data-aw-toggle-menu]');
      const nav = header?.querySelector('nav');
      
      if (!menuBtn || !header || !nav) return;

      // HELPER: Schließt ALLE Dropdowns (wichtig für sauberen Zustand)
      const closeAllDropdowns = () => {
        document.querySelectorAll('.dropdown > .expanded').forEach(el => {
            el.classList.remove('expanded');
            if (el.nextElementSibling) el.nextElementSibling.classList.add('hidden');
        });
      };

      // HELPER: Schließt das Mobile Menü komplett
      const closeMobileMenu = () => {
        menuBtn.classList.remove('expanded');
        document.body.classList.remove('overflow-hidden');
        header.classList.remove('h-screen');
        header.classList.remove('expanded');
        header.classList.remove('bg-page');
        nav.classList.add('hidden');
        closeAllDropdowns(); // Auch Dropdowns innen schließen
      };

      // 1. Mobile Toggle Button
      menuBtn.onclick = (e) => {
        e.stopPropagation(); // Verhindert Bubbling zum Document
        menuBtn.classList.toggle('expanded');
        document.body.classList.toggle('overflow-hidden');
        header.classList.toggle('h-screen');
        header.classList.toggle('expanded');
        header.classList.toggle('bg-page');
        nav.classList.toggle('hidden');
      };

      // 2. Dropdown Trigger Logic (Delegation)
      const onNavClick = (e) => {
        // Suche nach dem Button/Link, der das Dropdown öffnet
        const trigger = e.target.closest('.dropdown > button, .dropdown > a');
        
        if (trigger) {
            e.preventDefault();
            e.stopPropagation(); // WICHTIG: Damit der Klick nicht das "Document Close" feuert

            const isAlreadyOpen = trigger.classList.contains('expanded');

            // Erstmal alles schließen (Accordion-Effekt & Aufräumen)
            closeAllDropdowns();

            // Wenn es vorher NICHT offen war, jetzt öffnen. 
            // Wenn es offen war, bleibt es durch closeAllDropdowns() jetzt zu (Toggle-Effekt).
            if (!isAlreadyOpen) {
                trigger.classList.add('expanded');
                if (trigger.nextElementSibling) trigger.nextElementSibling.classList.remove('hidden');
            }
        }
      };

      // 3. Document Listener: Klick irgendwo anders hin schließt alles
      const onDocumentClick = (e) => {
        // Wenn Klick NICHT im Header/Nav war -> Alles zu
        if (!e.target.closest('#header nav') && !e.target.closest('[data-aw-toggle-menu]')) {
             closeMobileMenu(); // Schließt Mobile Menu wenn man daneben klickt
        }
        
        // Generell Dropdowns schließen, wenn man nicht gerade drin klickt
        // Ausnahme: Man klickt IN ein Dropdown Inhalt -> soll offen bleiben
        if (!e.target.closest('.dropdown')) {
             closeAllDropdowns();
        }
      };

      nav.addEventListener('click', onNavClick);
      document.addEventListener('click', onDocumentClick);

      // Expose für externe Nutzung
      window.awCloseMobileMenu = closeMobileMenu;

      cleanupFns.push(() => {
          menuBtn.onclick = null;
          nav.removeEventListener('click', onNavClick);
          document.removeEventListener('click', onDocumentClick);
      });
    };

    // --- 3. GLOBAL EVENTS (LINKS & SCROLL) ---
    const initGlobalEvents = () => {
      const onClick = (e) => {
        // Theme Toggle
        const themeBtn = e.target.closest('[data-aw-toggle-color-scheme]');
        if (themeBtn) {
          e.preventDefault();
          const themes = ['system', 'light', 'dark'];
          const current = localStorage.getItem('theme') || 'system';
          const next = themes[(themes.indexOf(current) + 1) % 3];
          localStorage.setItem('theme', next);
          applyTheme(next);
          return;
        }

        // Smooth Scroll & Link Handling
        const link = e.target.closest('a');
        if (link) {
            // Wenn es ein Link ist (egal ob Hash oder Seite): Menü schließen!
            if (window.awCloseMobileMenu) window.awCloseMobileMenu();

            // Speziell für Hash Links (#section) -> Smooth Scroll
            if (link.hash && link.origin === window.location.origin && link.pathname === window.location.pathname) {
                const targetEl = document.querySelector(link.hash);
                if (targetEl) {
                    e.preventDefault();
                    const headerHeight = getHeaderHeight();
                    const targetPos = targetEl.getBoundingClientRect().top + window.scrollY;
                    window.scrollTo({ top: targetPos - headerHeight, behavior: 'smooth' });
                    history.pushState(null, null, link.hash);
                }
            }
        }
      };

      document.addEventListener('click', onClick, { capture: true, passive: false });
      cleanupFns.push(() => document.removeEventListener('click', onClick, { capture: true }));
    };

    // --- 4. RELOAD SCROLL FIX ---
    const fixInitialHashScroll = () => {
        if (window.location.hash) {
            const target = document.querySelector(window.location.hash);
            if (target) {
                setTimeout(() => {
                    const headerHeight = getHeaderHeight();
                    const targetPos = target.getBoundingClientRect().top + window.scrollY;
                    window.scrollTo({ top: targetPos - headerHeight, behavior: 'instant' });
                }, 10);
            }
        }
    };

    // --- 5. ANIMATIONS ---
    const initAnimations = () => {
       const elements = document.querySelectorAll('.intersect, [class*="intersect:"]');
       if(!elements.length) return;
       const observer = new IntersectionObserver(entries => {
           entries.forEach(entry => {
               if(entry.isIntersecting) {
                   entry.target.setAttribute('data-aw-animated', 'true');
                   if (entry.target.classList.contains('intersect-once')) observer.unobserve(entry.target);
               }
           });
       }, {threshold: 0.1});
       elements.forEach(el => observer.observe(el));
       cleanupFns.push(() => observer.disconnect());
    };

    // --- RUN ---
    const run = () => {
      cleanupFns.forEach(fn => fn());
      cleanupFns = [];

      initTheme();
      initHeader();
      initMenu();

      setTimeout(() => {
          initGlobalEvents();
          fixInitialHashScroll();
      }, 0);

      if (window.requestIdleCallback) window.requestIdleCallback(initAnimations);
      else setTimeout(initAnimations, 200);
    };

    run();
    document.addEventListener('astro:after-swap', run);
  })();
</script>
