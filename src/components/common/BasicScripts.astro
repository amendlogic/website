---
import { UI } from 'astrowind:config';
---

<script is:inline define:vars={{ defaultTheme: UI.theme || 'system' }}>
  if (window.basic_script_init) return;
  window.basic_script_init = true;

  (function() {
    let cleanupFns = [];

    const attachEvent = (selector, event, fn) => {
      document.querySelectorAll(selector).forEach(el => el.addEventListener(event, fn));
    };

    const applyTheme = (theme) => {
      const resolvedTheme = (theme === 'system') 
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') 
        : theme;
      document.documentElement.classList.toggle('dark', resolvedTheme === 'dark');
      document.querySelectorAll('[data-aw-theme-icon]').forEach((icon) => {
        icon.classList.toggle('hidden', icon.getAttribute('data-aw-theme-icon') !== theme);
      });
    };

    const initScroll = () => {
      const stickyHeader = document.querySelector('#header[data-aw-sticky-header]');
      if (!stickyHeader) return;
      let isTicking = false;
      let lastState = false;

      const onScroll = () => {
        if (!isTicking) {
          window.requestAnimationFrame(() => {
            const isScrolled = window.scrollY > 10;
            if (isScrolled !== lastState) {
              stickyHeader.classList.toggle('scroll', isScrolled);
              lastState = isScrolled;
            }
            isTicking = false;
          });
          isTicking = true;
        }
      };
      window.addEventListener('scroll', onScroll, { passive: true });
      cleanupFns.push(() => window.removeEventListener('scroll', onScroll));
    };

    const setup = () => {
      const header = document.getElementById('header');
      const menuButton = document.querySelector('[data-aw-toggle-menu]');

      const toggleMenu = () => {
        if (!menuButton) return;
        menuButton.classList.toggle('expanded');
        document.body.classList.toggle('overflow-hidden');
        header?.classList.toggle('h-screen');
        header?.classList.toggle('expanded');
        header?.classList.toggle('bg-page');
        document.querySelector('#header nav')?.classList.toggle('hidden');
        document.querySelector('#header > div > div:last-child')?.classList.toggle('hidden');
      };

      if (menuButton) {
        menuButton.onclick = toggleMenu;
      }

      attachEvent('[data-aw-toggle-color-scheme]', 'click', () => {
        const themes = ['system', 'light', 'dark'];
        const current = localStorage.getItem('theme') || 'system';
        const next = themes[(themes.indexOf(current) + 1) % 3];
        localStorage.setItem('theme', next);
        applyTheme(next);
      });

      // --- ROBUSTER SMOOTH SCROLL FIX ---
      const onLinkClick = (e) => {
        const target = e.target.closest('a');
        
        if (target && target.hash && target.origin === window.location.origin && target.pathname === window.location.pathname) {
          const targetElement = document.querySelector(target.hash);
          
          if (targetElement) {
            // 1. Sofort verhindern, dass der Browser springt
            e.preventDefault();
            e.stopPropagation();

            // 2. Menü schließen falls offen
            if (header?.classList.contains('expanded')) {
              toggleMenu();
            }

            // 3. Offset berechnen
            const headerHeight = header ? header.getBoundingClientRect().height : 0;
            const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset;
            const finalPosition = targetPosition - headerHeight;

            // 4. Manueller Scroll-Befehl
            window.scrollTo({
              top: finalPosition,
              behavior: 'smooth'
            });

            // 5. URL Hash setzen ohne Sprung
            history.pushState(null, null, target.hash);
          }
        }
      };

      document.addEventListener('click', onLinkClick, { capture: true }); // Capture-Phase um anderen Skripten zuvorzukommen
      cleanupFns.push(() => document.removeEventListener('click', onLinkClick, { capture: true }));

      initScroll();
    };

    const initObserver = () => {
      if (observerInstance) observerInstance.disconnect();
      const selectors = ['[class*=" intersect:"]','[class*=":intersect:"]','[class^="intersect:"]','[class="intersect"]','.intersect-once','.intersect-quarter'];
      const elements = document.querySelectorAll(selectors.join(','));
      if (elements.length === 0) return;

      let animationCounter = 0;
      observerInstance = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const target = entry.target;
            if (!target.hasAttribute('data-aw-animated')) {
              target.setAttribute('data-aw-animated', 'true');
              target.removeAttribute('no-intersect');
              target.style.transitionDelay = `${animationCounter * 100}ms`;
              animationCounter++;
              if (target.classList.contains('intersect-once')) observerInstance.unobserve(target);
            }
          }
        });
      }, { threshold: [0, 0.25, 0.5] });

      elements.forEach((el) => {
        el.setAttribute('no-intersect', '');
        observerInstance.observe(el);
      });
    };

    let observerInstance = null;
    const run = () => {
      cleanupFns.forEach(fn => fn());
      cleanupFns = [];
      applyTheme(localStorage.getItem('theme') || 'system');
      setup();
      window.requestAnimationFrame(initObserver);
    };

    run();
    document.addEventListener('astro:after-swap', run);
  })();
</script>
