---
import { UI } from 'astrowind:config';
---

<script is:inline define:vars={{ defaultTheme: UI.theme || 'system' }}>
  // Singleton Pattern
  if (window.basic_script_init) return;
  window.basic_script_init = true;

  (function() {
    let cleanupFns = [];

    // --- HELPER ---
    const getHeaderHeight = () => {
      const header = document.getElementById('header');
      return header ? header.getBoundingClientRect().height : 0;
    };

    // --- THEME ---
    const applyTheme = (theme) => {
      const resolvedTheme = (theme === 'system') 
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') 
        : theme;
      
      requestAnimationFrame(() => {
        if (resolvedTheme === 'dark') document.documentElement.classList.add('dark');
        else document.documentElement.classList.remove('dark');
        
        document.querySelectorAll('[data-aw-theme-icon]').forEach((icon) => {
          if (icon.getAttribute('data-aw-theme-icon') === theme) icon.classList.remove('hidden');
          else icon.classList.add('hidden');
        });
      });
    };

    const initTheme = () => {
      const stored = localStorage.getItem('theme') || defaultTheme;
      applyTheme(stored);
    };

    // --- 1. HEADER SCROLL STATE ---
    const initHeader = () => {
      const header = document.getElementById('header');
      const stickyHeader = document.querySelector('#header[data-aw-sticky-header]');
      if (!stickyHeader) return;

      let isTicking = false;
      const onScroll = () => {
        if (!isTicking) {
          window.requestAnimationFrame(() => {
            stickyHeader.classList.toggle('scroll', window.scrollY > 10);
            isTicking = false;
          });
          isTicking = true;
        }
      };

      window.addEventListener('scroll', onScroll, { passive: true });
      if (window.scrollY > 10) stickyHeader.classList.add('scroll');
      cleanupFns.push(() => window.removeEventListener('scroll', onScroll));
    };

    // --- 2. MENU LOGIK (ORIGINAL + ROBUST) ---
    const initMenu = () => {
      const header = document.getElementById('header');
      const menuBtn = document.querySelector('[data-aw-toggle-menu]');
      const nav = header?.querySelector('nav');
      
      if (!menuBtn || !header || !nav) return;

      // Die Funktion zum kompletten Schließen (Original-Logik + Dropdown Fix)
      const closeMenu = () => {
        // 1. Original Logik: Mobile Menu Reset
        menuBtn.classList.remove('expanded');
        document.body.classList.remove('overflow-hidden');
        header.classList.remove('h-screen');
        header.classList.remove('expanded');
        header.classList.remove('bg-page');
        nav.classList.add('hidden');
        document.querySelector('#header > div > div:last-child')?.classList.add('hidden');

        // 2. Zusatz für Desktop: Auch offene Dropdowns schließen
        const expandedDropdowns = document.querySelectorAll('.dropdown > .expanded');
        expandedDropdowns.forEach(el => {
            el.classList.remove('expanded');
            if (el.nextElementSibling) el.nextElementSibling.classList.add('hidden');
        });
      };

      // Toggle Funktion für den Hamburger Button
      menuBtn.onclick = (e) => {
        e.stopPropagation(); // Verhindert, dass der Klick gleich wieder das Menü schließt
        menuBtn.classList.toggle('expanded');
        document.body.classList.toggle('overflow-hidden');
        header.classList.toggle('h-screen');
        header.classList.toggle('expanded');
        header.classList.toggle('bg-page');
        nav.classList.toggle('hidden');
        document.querySelector('#header > div > div:last-child')?.classList.toggle('hidden');
      };

      // Event Delegation für Dropdowns
      const onNavClick = (e) => {
        const trigger = e.target.closest('.dropdown > button, .dropdown > a');
        if (trigger) {
            // Dropdown Logik
            e.preventDefault(); 
            // Andere Dropdowns schließen (Accordion Effekt, optional aber sauber)
            const parent = trigger.closest('.dropdown').parentElement;
            if(parent) {
                parent.querySelectorAll('.expanded').forEach( sib => {
                    if(sib !== trigger) {
                        sib.classList.remove('expanded');
                        if(sib.nextElementSibling) sib.nextElementSibling.classList.add('hidden');
                    }
                });
            }
            trigger.classList.toggle('expanded');
            if (trigger.nextElementSibling) trigger.nextElementSibling.classList.toggle('hidden');
            e.stopPropagation(); // Damit der "Schließen"-Listener am Nav nicht feuert
        }
      };

      // WICHTIG: Das ist die Logik aus deinem Original-Skript
      // Bei Klick auf Nav (Hintergrund oder Links) -> Alles schließen
      const onNavGeneralClick = (e) => {
         // Nur schließen, wenn wir NICHT gerade ein Dropdown oder den Toggle geklickt haben
         if (!e.target.closest('.dropdown > button')) {
             closeMenu();
         }
      };

      nav.addEventListener('click', onNavClick);     // Für Dropdown Toggle
      nav.addEventListener('click', onNavGeneralClick); // Zum Schließen bei Links

      // Expose closeMenu für den Scroll-Handler
      window.awCloseMenu = closeMenu;

      cleanupFns.push(() => {
          menuBtn.onclick = null;
          nav.removeEventListener('click', onNavClick);
          nav.removeEventListener('click', onNavGeneralClick);
      });
    };

    // --- 3. GLOBAL EVENTS (LINKS & SCROLL) ---
    const initGlobalEvents = () => {
      const onClick = (e) => {
        // Theme Toggle
        const themeBtn = e.target.closest('[data-aw-toggle-color-scheme]');
        if (themeBtn) {
          e.preventDefault();
          const themes = ['system', 'light', 'dark'];
          const current = localStorage.getItem('theme') || 'system';
          const next = themes[(themes.indexOf(current) + 1) % 3];
          localStorage.setItem('theme', next);
          applyTheme(next);
          return;
        }

        // Smooth Scroll & Menu Close
        const link = e.target.closest('a');
        if (link && link.hash && link.origin === window.location.origin && link.pathname === window.location.pathname) {
          const targetEl = document.querySelector(link.hash);
          if (targetEl) {
            e.preventDefault();
            
            // Menü schließen (über die oben definierte Logik)
            if (window.awCloseMenu) window.awCloseMenu();
            
            const headerHeight = getHeaderHeight();
            const targetPos = targetEl.getBoundingClientRect().top + window.scrollY;
            
            window.scrollTo({ top: targetPos - headerHeight, behavior: 'smooth' });
            history.pushState(null, null, link.hash);
          }
        }
      };

      document.addEventListener('click', onClick, { capture: true, passive: false });
      cleanupFns.push(() => document.removeEventListener('click', onClick, { capture: true }));
    };

    // --- 4. RELOAD SCROLL FIX ---
    // Lädt die Seite an der korrekten Position (Header offset) neu
    const fixInitialHashScroll = () => {
        if (window.location.hash) {
            const target = document.querySelector(window.location.hash);
            if (target) {
                // setTimeout 0 reicht oft, um dem Browser Render-Zeit zu geben
                setTimeout(() => {
                    const headerHeight = getHeaderHeight();
                    const targetPos = target.getBoundingClientRect().top + window.scrollY;
                    window.scrollTo({ top: targetPos - headerHeight, behavior: 'instant' });
                }, 10);
            }
        }
    };

    // --- 5. ANIMATIONS ---
    const initAnimations = () => {
       const elements = document.querySelectorAll('.intersect, [class*="intersect:"]');
       if(!elements.length) return;
       const observer = new IntersectionObserver(entries => {
           entries.forEach(entry => {
               if(entry.isIntersecting) {
                   entry.target.setAttribute('data-aw-animated', 'true');
                   if (entry.target.classList.contains('intersect-once')) observer.unobserve(entry.target);
               }
           });
       }, {threshold: 0.1});
       elements.forEach(el => observer.observe(el));
       cleanupFns.push(() => observer.disconnect());
    };

    // --- RUN ---
    const run = () => {
      cleanupFns.forEach(fn => fn());
      cleanupFns = [];

      initTheme();
      initHeader();
      initMenu();

      // Events asynchron initialisieren für Performance
      setTimeout(() => {
          initGlobalEvents();
          fixInitialHashScroll(); // Fix für Reload-Position
      }, 0);

      if (window.requestIdleCallback) window.requestIdleCallback(initAnimations);
      else setTimeout(initAnimations, 200);
    };

    run();
    document.addEventListener('astro:after-swap', run);
  })();
</script>
