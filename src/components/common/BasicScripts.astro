---
import { UI } from 'astrowind:config';
---

<script is:inline define:vars={{ defaultTheme: UI.theme || 'system' }}>
  if (window.basic_script_init) return;
  window.basic_script_init = true;

  (function() {
    let cleanupFns = [];

    // --- 1. THEME LOGIK ---
    const applyTheme = (theme) => {
      const resolvedTheme = (theme === 'system') 
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') 
        : theme;
      
      document.documentElement.classList.toggle('dark', resolvedTheme === 'dark');
      document.querySelectorAll('[data-aw-theme-icon]').forEach((icon) => {
        icon.classList.toggle('hidden', icon.getAttribute('data-aw-theme-icon') !== theme);
      });
    };

    // --- 2. HEADER & MENU ---
    const initHeaderAndMenu = () => {
      const header = document.getElementById('header');
      const menuBtn = document.querySelector('[data-aw-toggle-menu]');
      const stickyHeader = document.querySelector('#header[data-aw-sticky-header]');
      const nav = header?.querySelector('nav');

      if (!header) return;

      // Sticky Header Scroll Logik
      const onScroll = () => {
        const isScrolled = window.scrollY > 10;
        if (stickyHeader) stickyHeader.classList.toggle('scroll', isScrolled);
      };
      window.addEventListener('scroll', onScroll, { passive: true });
      onScroll();

      // Menü Toggle Funktion
      const toggleMenu = (forceClose = false) => {
        const isExpanded = header.classList.contains('expanded');
        if (forceClose && !isExpanded) return;

        menuBtn?.classList.toggle('expanded', !forceClose && !isExpanded);
        document.body.classList.toggle('overflow-hidden', !forceClose && !isExpanded);
        header.classList.toggle('expanded', !forceClose && !isExpanded);
        header.classList.toggle('h-screen', !forceClose && !isExpanded);
        header.classList.toggle('bg-page', !forceClose && !isExpanded);
        nav?.classList.toggle('hidden', forceClose || isExpanded);
        
        const actions = header.querySelector('nav + div') || header.querySelector('div > div:last-child');
        if (actions) actions.classList.toggle('hidden', forceClose || isExpanded);
        
        const icons = menuBtn?.querySelectorAll('svg, [data-aw-icon]');
        if (icons?.length > 1) {
          icons[0].classList.toggle('hidden', !forceClose && !isExpanded);
          icons[1].classList.toggle('hidden', forceClose || isExpanded);
        }
      };

      if (menuBtn) menuBtn.onclick = () => toggleMenu();

      // Dropdown Logik im Menü (Mobile)
      const onNavClick = (e) => {
        const trigger = e.target.closest('.dropdown > button, .dropdown > a');
        if (!trigger || window.getComputedStyle(menuBtn).display === 'none') return;
        const subMenu = trigger.nextElementSibling;
        if (subMenu) {
            e.preventDefault();
            subMenu.classList.toggle('hidden');
            trigger.classList.toggle('expanded');
        }
      };
      nav?.addEventListener('click', onNavClick);

      // Exponieren für Global Click
      window.forceCloseMenuInstance = () => toggleMenu(true);

      cleanupFns.push(() => {
        window.removeEventListener('scroll', onScroll);
        nav?.removeEventListener('click', onNavClick);
      });
    };

    // --- 3. SCROLL & HASH MANAGEMENT (THE CORE) ---
    const setupScrollBehavior = () => {
      const html = document.documentElement;

      // A. Initialer Jump (verhindert Scrollen beim Refresh)
      const handleInitialHash = () => {
        if (window.location.hash) {
          const target = document.querySelector(window.location.hash);
          if (target) {
            // Smooth Scroll temporär deaktivieren
            html.style.scrollBehavior = 'auto';
            window.scrollTo(0, target.offsetTop - 80); // 80px Offset für Header
            
            // Erst danach Smooth Scroll für User-Aktionen aktivieren
            setTimeout(() => {
              html.style.scrollBehavior = 'smooth';
            }, 100);
          }
        } else {
          html.style.scrollBehavior = 'smooth';
        }
      };

      // B. Klick-Interception
      const handleGlobalClick = (e) => {
        const target = e.target.closest('a');
        if (!target) return;

        const themeBtn = target.closest('[data-aw-toggle-color-scheme]');
        if (themeBtn) {
          const themes = ['system', 'light', 'dark'];
          const next = themes[(themes.indexOf(localStorage.getItem('theme') || 'system') + 1) % 3];
          localStorage.setItem('theme', next);
          applyTheme(next);
          return;
        }

        // Anker-Link Logik
        if (target.hash && target.origin === window.location.origin && target.pathname === window.location.pathname) {
          // 1. Menü SOFORT schließen (Wichtig für Layout-Stabilität)
          if (window.forceCloseMenuInstance) {
            window.forceCloseMenuInstance();
          }

          // 2. Falls wir schon auf dem Hash sind, scrollen wir manuell (Browser macht das sonst oft nicht)
          const element = document.querySelector(target.hash);
          if (element) {
            e.preventDefault();
            const offset = 80; // Dein Header-Offset
            const elementPosition = element.getBoundingClientRect().top + window.pageYOffset;
            window.scrollTo({
              top: elementPosition - offset,
              behavior: 'smooth'
            });
            // Hash in URL aktualisieren ohne Sprung
            history.pushState(null, null, target.hash);
          }
        }
      };

      document.addEventListener('click', handleGlobalClick);
      handleInitialHash();

      cleanupFns.push(() => document.removeEventListener('click', handleGlobalClick));
    };

    // --- 4. RUN & LIFECYCLE ---
    const run = () => {
      cleanupFns.forEach(fn => fn());
      cleanupFns = [];

      applyTheme(localStorage.getItem('theme') || 'system');
      initHeaderAndMenu();
      setupScrollBehavior();

      // Intersection Observer für Animationen
      const elements = document.querySelectorAll('[class*="intersect:"]');
      if (elements.length > 0) {
        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.setAttribute('data-aw-animated', 'true');
            }
          });
        }, { threshold: 0.1 });
        elements.forEach(el => observer.observe(el));
        cleanupFns.push(() => observer.disconnect());
      }
    };

    run();
    document.addEventListener('astro:after-swap', run);
  })();
</script>