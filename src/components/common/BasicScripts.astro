---
import { UI } from 'astrowind:config';
---

<script is:inline define:vars={{ defaultTheme: UI.theme || 'system' }}>
  // Verhindert doppelte Ausführung, aber erlaubt Re-Init bei View Transitions
  if (!window.basic_script_init) {
    window.basic_script_init = true;

    (() => {
      // Speichert Cleanup-Funktionen für View Transitions
      let cleanupFns = [];

      // --- UTILS ---
      // Optimierte DOM-Operationen
      const toggleClass = (el, className, condition) => {
        if (!el) return;
        el.classList.toggle(className, condition);
      };

      // --- 1. THEME MANAGER ---
      const initTheme = () => {
        const updateTheme = () => {
          const stored = localStorage.getItem('theme') || defaultTheme;
          const isDark = stored === 'dark' || (stored === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);
          
          toggleClass(document.documentElement, 'dark', isDark);
          
          // Icon Updates batching
          requestAnimationFrame(() => {
            document.querySelectorAll('[data-aw-theme-icon]').forEach((icon) => {
              const iconTheme = icon.dataset.awThemeIcon;
              toggleClass(icon, 'hidden', iconTheme !== stored);
            });
          });
        };

        // Initiale Anwendung
        updateTheme();

        // Listener für Systemänderungen (Live-Update)
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        const onMediaChange = () => {
          if ((localStorage.getItem('theme') || defaultTheme) === 'system') updateTheme();
        };
        
        mediaQuery.addEventListener('change', onMediaChange);
        cleanupFns.push(() => mediaQuery.removeEventListener('change', onMediaChange));

        // Event Delegation für Theme-Toggle Button
        const onThemeToggle = (e) => {
          const btn = e.target.closest('[data-aw-toggle-color-scheme]');
          if (!btn) return;

          const current = localStorage.getItem('theme') || defaultTheme;
          const themes = ['system', 'light', 'dark'];
          const next = themes[(themes.indexOf(current) + 1) % themes.length];
          
          localStorage.setItem('theme', next);
          updateTheme();
        };

        document.addEventListener('click', onThemeToggle);
        cleanupFns.push(() => document.removeEventListener('click', onThemeToggle));
      };

      // --- 2. HEADER LOGIK (PERFORMANCE OPTIMIZED) ---
      const initHeader = () => {
        const header = document.querySelector('#header[data-aw-sticky-header]');
        if (!header) return;

        // IntersectionObserver ist performanter als ein Scroll-Listener
        // Wir erstellen einen unsichtbaren Pixel oben, um zu prüfen, ob gescrollt wurde.
        const sentinel = document.createElement('div');
        sentinel.setAttribute('data-scroll-watcher', '');
        header.before(sentinel);

        const observer = new IntersectionObserver((entries) => {
          // Wenn Sentinel NICHT sichtbar ist, sind wir gescrollt
          header.classList.toggle('scroll', !entries[0].isIntersecting);
        }, { rootMargin: '10px 0px 0px 0px' }); // Puffer von 10px wie im Original

        observer.observe(sentinel);
        cleanupFns.push(() => {
          observer.disconnect();
          sentinel.remove();
        });
      };

      // --- 3. MENU LOGIK (ACCESSIBILITY UPDATED) ---
      const initMenu = () => {
        const header = document.getElementById('header');
        const menuBtn = document.querySelector('[data-aw-toggle-menu]');
        const nav = header?.querySelector('nav');
        
        if (!menuBtn || !header || !nav) return;

        const toggleMenu = (forceState) => {
          const isExpanded = typeof forceState === 'boolean' ? forceState : !menuBtn.classList.contains('expanded');
          
          menuBtn.classList.toggle('expanded', isExpanded);
          menuBtn.setAttribute('aria-expanded', isExpanded); // A11y
          document.body.classList.toggle('overflow-hidden', isExpanded);
          
          header.classList.toggle('h-screen', isExpanded);
          header.classList.toggle('expanded', isExpanded);
          header.classList.toggle('bg-page', isExpanded);

          nav.classList.toggle('hidden', !isExpanded);
          nav.setAttribute('aria-hidden', !isExpanded); // A11y

          // Toggle Icons (Hamburger vs Close)
          const icons = menuBtn.querySelectorAll('svg, [data-aw-icon]');
          if (icons.length > 1) {
             icons.forEach(icon => icon.classList.toggle('hidden'));
          }
        };

        menuBtn.onclick = () => toggleMenu();

        // Dropdowns via Event Delegation
        const onNavClick = (e) => {
          const trigger = e.target.closest('.dropdown > button, .dropdown > a');
          if (trigger && window.getComputedStyle(menuBtn).display !== 'none') {
            e.preventDefault();
            const subMenu = trigger.nextElementSibling;
            const isExpanded = !subMenu.classList.contains('hidden');
            
            trigger.classList.toggle('expanded', !isExpanded);
            trigger.setAttribute('aria-expanded', !isExpanded);
            subMenu.classList.toggle('hidden', isExpanded);
          }
        };

        nav.addEventListener('click', onNavClick);
        cleanupFns.push(() => nav.removeEventListener('click', onNavClick));

        // Expose für Global Click Handler
        window.closeMenuIfOpen = () => {
          if (menuBtn.classList.contains('expanded')) toggleMenu(false);
        };
      };

      // --- 4. SCROLL & ANIMATIONS ---
      const initUX = () => {
        // Smooth Scroll für Anchor Links + Menü schließen
        const onLinkClick = (e) => {
          const link = e.target.closest('a');
          if (link && link.hash && link.origin === location.origin && link.pathname === location.pathname) {
            if (window.closeMenuIfOpen) window.closeMenuIfOpen();
          }
        };
        
        document.addEventListener('click', onLinkClick, { capture: true });
        cleanupFns.push(() => document.removeEventListener('click', onLinkClick, { capture: true }));

        // Animations via IntersectionObserver
        const animateElements = document.querySelectorAll('.intersect, [class*="intersect:"]');
        if (animateElements.length) {
          const obs = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                entry.target.setAttribute('data-aw-animated', 'true');
                if (entry.target.classList.contains('intersect-once')) obs.unobserve(entry.target);
              }
            });
          }, { threshold: 0.1 });

          animateElements.forEach(el => obs.observe(el));
          cleanupFns.push(() => obs.disconnect());
        }
      };

      // --- LIFECYCLE CONTROLLER ---
      const setup = () => {
        // Cleanup alter Listener (wichtig für SPA/View Transitions)
        cleanupFns.forEach(fn => fn());
        cleanupFns = [];

        initTheme();
        initHeader();
        initMenu();
        
        // Defer UX logic slightly to prioritize LCP
        if (window.requestIdleCallback) {
          window.requestIdleCallback(initUX);
        } else {
          setTimeout(initUX, 100);
        }
      };

      // Nutze den modernen 'astro:page-load' Event (deckt init und swap ab)
      document.addEventListener('astro:page-load', setup);
      
      // Fallback, falls keine View Transitions genutzt werden
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setup);
      } else {
        setup();
      }

    })();
  }
</script>