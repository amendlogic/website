---
import { UI } from 'astrowind:config';
---

<script is:inline define:vars={{ defaultTheme: UI.theme || 'system' }}>
  // Singleton Pattern: Verhindert doppelte Ausführung
  if (window.basic_script_init) return;
  window.basic_script_init = true;

  (function() {
    // Memory Management: Stack für Cleanup-Funktionen
    let cleanupFns = [];

    // --- UTILS ---
    
    // Performance: Helper um CSS-Klassen effizient zu toggeln
    const toggleClass = (el, className, condition) => {
      if (condition) el.classList.add(className);
      else el.classList.remove(className);
    };

    // --- THEME LOGIK (Optimiert) ---
    const applyTheme = (theme) => {
      const resolvedTheme = (theme === 'system') 
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') 
        : theme;
      
      // Nutzt requestAnimationFrame für DOM-Updates um Repaints zu bündeln
      requestAnimationFrame(() => {
        toggleClass(document.documentElement, 'dark', resolvedTheme === 'dark');
        document.querySelectorAll('[data-aw-theme-icon]').forEach((icon) => {
          toggleClass(icon, 'hidden', icon.getAttribute('data-aw-theme-icon') !== theme);
        });
      });
    };

    // --- HEADER LOGIK (Passive Scroll Listener) ---
    const initHeader = () => {
      const header = document.getElementById('header');
      const stickyHeader = document.querySelector('#header[data-aw-sticky-header]');
      if (!stickyHeader) return;

      let lastScrollY = window.scrollY;
      let isTicking = false;

      const onScroll = () => {
        lastScrollY = window.scrollY;
        if (!isTicking) {
          window.requestAnimationFrame(() => {
            toggleClass(stickyHeader, 'scroll', lastScrollY > 10);
            isTicking = false;
          });
          isTicking = true;
        }
      };

      // { passive: true } ist der Schlüssel für 60FPS Scrollen auf Mobile
      window.addEventListener('scroll', onScroll, { passive: true });
      cleanupFns.push(() => window.removeEventListener('scroll', onScroll));
      
      // Initial State check
      onScroll(); 
    };

    // --- MENU LOGIK ---
    const initMenu = () => {
      const header = document.getElementById('header');
      const menuBtn = document.querySelector('[data-aw-toggle-menu]');
      
      if (!menuBtn || !header) return;

      const toggleMenu = () => {
        menuBtn.classList.toggle('expanded');
        document.body.classList.toggle('overflow-hidden');
        header.classList.toggle('h-screen');
        header.classList.toggle('expanded');
        header.classList.toggle('bg-page');
        
        // Suche Elemente nur einmal bei Bedarf
        const nav = header.querySelector('nav');
        const actions = header.querySelector('div > div:last-child'); // Action buttons
        
        if (nav) nav.classList.toggle('hidden');
        if (actions) actions.classList.toggle('hidden');
      };

      menuBtn.onclick = toggleMenu; // Memory effizienter als addEventListener für Singles

      // Expose für Smooth Scroll Zugriff
      window.toggleMenuInstance = toggleMenu; 
    };

    // --- GLOBAL CLICK HANDLER (Event Delegation) ---
    // Ein einziger Listener für Theme, Links und Smooth Scroll
    const initGlobalEvents = () => {
      const header = document.getElementById('header');
      
      const onClick = (e) => {
        // 1. Theme Toggle Check
        const themeBtn = e.target.closest('[data-aw-toggle-color-scheme]');
        if (themeBtn) {
          const themes = ['system', 'light', 'dark'];
          const current = localStorage.getItem('theme') || 'system';
          const next = themes[(themes.indexOf(current) + 1) % 3];
          localStorage.setItem('theme', next);
          applyTheme(next);
          return; // Early return spart CPU
        }

        // 2. Smooth Scroll & Link Handling
        const link = e.target.closest('a');
        if (link && link.hash && link.origin === window.location.origin && link.pathname === window.location.pathname) {
          const targetEl = document.querySelector(link.hash);
          if (targetEl) {
            e.preventDefault(); // Browser-Sprung verhindern
            
            // Mobile Menu schließen falls offen
            if (header?.classList.contains('expanded') && window.toggleMenuInstance) {
              window.toggleMenuInstance();
            }

            // Desktop Dropdown-Fokus entfernen
            link.blur();

            // Berechnung in rAF für Performance
            requestAnimationFrame(() => {
              const headerHeight = header ? header.getBoundingClientRect().height : 0;
              const targetPos = targetEl.getBoundingClientRect().top + window.scrollY;
              
              window.scrollTo({
                top: targetPos - headerHeight,
                behavior: 'smooth'
              });
              
              // History State ohne Sprung
              history.pushState(null, null, link.hash);
            });
          }
        }
      };

      // Capture Phase: true, um schneller zu sein als andere Scripts
      document.addEventListener('click', onClick, { capture: true });
      cleanupFns.push(() => document.removeEventListener('click', onClick, { capture: true }));
    };

    // --- INTERSECT OBSERVER (Idle Initialization) ---
    const initObserver = () => {
      const selectors = ['[class*=" intersect:"]','[class*=":intersect:"]','[class^="intersect:"]','[class="intersect"]','.intersect-once','.intersect-quarter'];
      const elements = document.querySelectorAll(selectors.join(','));
      
      if (elements.length === 0) return;

      let observer;
      let animationCounter = 0;

      const callback = (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const el = entry.target;
            if (!el.hasAttribute('data-aw-animated')) {
              el.setAttribute('data-aw-animated', 'true');
              el.removeAttribute('no-intersect');
              el.style.transitionDelay = `${animationCounter * 100}ms`;
              
              // Counter resetten via Timeout, damit er nicht unendlich wächst
              // aber Gruppierungen beibehält
              if (animationCounter === 0) {
                 setTimeout(() => { animationCounter = 0; }, 500);
              }
              animationCounter++;

              if (el.classList.contains('intersect-once')) observer.unobserve(el);
            }
          }
        });
      };

      observer = new IntersectionObserver(callback, { threshold: 0.1 });
      elements.forEach(el => {
        el.setAttribute('no-intersect', '');
        observer.observe(el);
      });

      cleanupFns.push(() => observer.disconnect());
    };

    // --- LIFECYCLE CONTROLLER ---
    const start = () => {
      // Cleanup first
      cleanupFns.forEach(fn => fn());
      cleanupFns = [];

      // Blocking Tasks (sofort nötig)
      applyTheme(localStorage.getItem('theme') || 'system');
      initHeader();
      initMenu();
      initGlobalEvents();

      // Non-Blocking Tasks (können warten -> PageSpeed Boost)
      if (window.requestIdleCallback) {
        window.requestIdleCallback(initObserver);
      } else {
        setTimeout(initObserver, 200);
      }
    };

    // Start
    start();
    document.addEventListener('astro:after-swap', start);
  })();
</script>
